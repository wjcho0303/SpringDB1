* 일반적으로 웹 서비스에서 모바일 앱이나 웹 브라우저가 DB와 직접적으로 연결되어 있지 않고,
'애플리케이션 서버'가 중간에 존재한다. 서버는 클라이언트의 요청을 받아 비즈니스 로직을 수행하고
처리 결과를 응답 및 DB에 저장하는 구조로 이루어져 있다.

* 애플리케이션 서버와 DB는 TCP/IP를 사용해서 커넥션을 연결한다.
이러한 상황에서 서버는 커넥션을 통해 DB가 이해할 수 있는 SQL을 DB에 전달하고,
DB는 전달받은 SQL을 수행한 후 애플리케이션 서버에 응답을 해준다.
애플리케이션은 이 응답 결과를 활용하여 비즈니스 로직을 수행한다.



- JDBC의 등장 이유
DB마다 DB의 사용법이 조금씩 다르다. SQL 문법에서부터, 커넥션을 연결하는 방법도 다르다.  
이러한 서로 다른 RDBMS가 수십 가지나 있다.
그렇기 때문에 예전에는 만약 한 DB를 사용하다가 다른 DB로 교체할 경우
애플리케이션 서버에 개발된 DB 사용과 관련된 코드들도 함께 변경했어야 했다. 
그렇기 때문에 개발자는 사용할 DB의 커넥션 연결, SQL 전달, 결과 응답 받기 등에 대해 학습했어야 했다.

이러한 문제를 해결하기 위해 1997년에 JDBC가 출시되었다. 
JDBC는 Java Database Connectivity의 줄임말로, 자바에서 DB에 접속할 수 있게 해주는 자바 API이다.
JDBC 표준 인터페이스는 크게 3가지이다: 
    1) Connection 연결 (java.sql.Connection)
    2) Statement SQL 전달 (java.sql.Statement)
    3) ResultSet 결과 응답 (java.sql.ResultSet)

즉, 연결 방식, SQL 전달 방식, 결과 응답 방식이 모두 추상화되어 개발자가 더 유연하게 DB를 활용할 수 있는
표준 인터페이스를 제공한다. 

JDBC에서 제공하는 표준 인터페이스에 대해, 각각의 DB 벤더들은 자신의 DB에 맞게 구현해서 라이브러리로 제공한다.
벤더들이 제공하는 이 라이브러리들을 "JDBC 드라이버"라고 한다. JDBC 드라이버는 MySQL JDBC 드라이버,
Oracle JDBC 드라이버 등 다양한 JDBC 드라이버들이 존재한다.

JDBC가 등장함으로써 DB가 변경되어도 애플리케이션 서버의 사용 코드를 유지할 수 있게 되었다.
또, 개발자가 사용할 DB Connection 연결, SQL 전달 방식, 결과 응답 방식까지 학습할 필요는 없어졌다.



- JDBC의 한계: SQL 표준화의 한계
JDBC는 DB Connection 연결, SQL 전달 방식, 결과 응답 방식에 대한 표준화를 이루었지만
각각의 데이터베이스마다 SQL문 문법이 조금씩 다르고 데이터 타입 등 일부 사용법이 다른 것까지 
모두 커버하지는 못했다. 'ANSI SQL'이라는 SQL 표준이 있기는 하지만 일반적인 부분만 표준화되었기 때문에 세부적인
영역까지 표준화하는 것은 불가능하다. 예를 들면 실무에서 굉장히 많이 사용되는 '페이징' 기능은 DB마다
사용법이 굉장히 다르다.

결론적으로, DB를 변경하면 JDBC 코드를 변경하지 않아도 되지만, SQL문은 해당 DB에 맞게 수정해줘야 한다는
한계점이 남아 있었다. 이러한 문제를 해결해준 것이 JPA다.



- JDBC와 최신 데이터 접근 기술
최근에는 JDBC를 직접 사용하기 보다는 JDBC를 편리하게 사용하게 해주는 기술을 사용하는데,
대표적으로 SQL Mapper와 ORM 기술로 나눌 수 있다.

1) SQL Mapper
SQL Mapper는 JDBC를 편리하게 사용할 수 있게 도와주는 기술이다.
대표적인 기술로 Spring JdbcTemplate과 MyBatis가 있다.

    장점)
    * 순수 JDBC는 SQL 응답 결과를 객체로 바꾸는 과정이 복잡한데, SQL 응답 결과를 객체로 편리하게 반환해준다.
    * SQL만 직접 작성하면 나머지 번거로운 일은 SQL Mapper가 대신 해결해준다.
    * JDBC의 반복적인 코드들이 많이 줄어든다. 

    단점)
    * 개발자가 SQL을 직접 작성해야 한다.


2) ORM 기술(JPA)
ORM은 객체(엔티티)를 RDBMS 테이블과 매핑해주는 기술이다.
JPA는 자바 진영의 ORM 표준 인터페이스고, 이것을 Hibernate와 EclipseLink가 구현하는데, 대다수의 경우
Hibernate를 사용한다.
 
ORM 덕분에 개발자는 반복적인 SQL을 직접 작성하지 않고, ORM 기술이 개발자 대신에 SQL을 동적으로 만들어
실행해준다. 추가로 각각의 DB마다 다른 SQL을 사용하는 문제도 중간에서 해결해준다.

ORM 기술에서는 애플리케이션에서 쿼리를 전달하는 게 아니라 엔티티 객체를 JPA에게 전달해준다.
그러면 JPA 구현체가 엔티티 매핑 정보를 보고 쿼리를 대신 만들어주며, 만든 쿼리를 JDBC에 전달해준다.
그 후 JDBC는 하부 로직을 통해 DB와 상호작용한다.

    장점)
    * SQL을 작성하지 않아도 되기 때문에 개발 생산성이 높아진다.
    
    단점)
    * 쉬운 기술이 아니므로 실무에서 사용하기 위해서는 깊이 있기 학습해야 한다.

중요한 것은, SQL Mapper든 ORM이든 하부에서는 JDBC를 사용하고 있다는 것을 기억해야 한다.
JDBC를 직접 사용하지는 않겠지만 JDBC가 하부에서 어떻게 동작하는지 기본 원리를 알아두어야 한다.
그래야 그 상부의 기술들의 필요성을 정확하게 이해할 수 있고, 문제가 발생했을 때 문제의 근본적인 원인을 
더 쉽게 찾을 수 있다.

    

- DB 연결하기

* Connection에 사용될 상수 정의하기 
public abstract class ConnectionConstant {  // 상수만 다루므로 객체를 생성하면 안 되기 때문에 abstract
    public static final String URL = "jdbc:h2:tcp://localhost/~/test";
    public static final String USERNAME = "sa";
    public static final String PASSWORD = "";
}


* DB 연결을 위한 유틸리티 클래스 생성하기
@Slf4j
public class DBConnectionUtil {

    public static Connection getConnection() {

        try {
            Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);
            log.info("get connection={}, class={}", connection, connection.getClass());
            return connection;
        } catch (SQLException e) {
            throw new IllegalStateException(e);
        }

    }
}

getConnection() 메서드는 특정 DB에 연결을 생성하고, 그 연결을 반환한다.
그리고 생성된 연결 정보를 로깅한다. 

동작 과정은 다음과 같다: 
1) DB연결이 필요한 곳에서 DBConnectionUtil.getConnection() 메서드 호출
2) 내부 로직에서 DriverManager.getConnection()을 호출하여 데이터베이스 연결을 시도
    DriverManager.getConnection()은 라이브러리에 있는 DB 드라이버를 찾아서 해당 드라이버가 제공하는
    Connection을 반환해준다. 본 실습에서는 H2 Database를 사용하므로 H2 Driver의 Connection이 반환된다.
    
    * DriverManager.getConnection() 메서드는 JDBC API의 핵심 메서드 중 하나로, DB 연결을 설정하는 역할을 한다.

3) 연결이 성공하면 Connection 객체 반환 및 로깅



- Connection 테스트 코드
    @Test
    void connection() {
        Connection connection = DBConnectionUtil.getConnection();
        assertThat(connection).isNotNull();
    }

로그:
[main] INFO hello.springdb.connection.DBConnectionUtil --
get connection=conn0: url=jdbc:h2:tcp://localhost/~/test user=SA, class=class org.h2.jdbc.JdbcConnection

로그를 보면 class={} 부분에 JdbcConnection이 나타나 있다.
왜냐하면 반환 받은 Connection은 인터페이스이기 때문이다. 
Connection의 구현체는 DB 벤더마다 이름이 다르며, H2의 경우 구현체의 이름이 JdbcConnection이다.

    public interface Connection  extends Wrapper, AutoCloseable {
	... 
    }

MySQL의 경우 MySQLConnection, Oracle의 경우 OracleConnection이며,
본 실습에서는 H2Driver를 사용하고 있기 때문에 H2의 Connection인 JdbcConnection이 반환된 것이다.
만약 실습에서 사용한 DB Driver가 MySQLDriver 이었다면 class={} 부분에 MySQLConnection이 로그로 기록되었을 것이다.

개발자는 그냥 Connection connection = DriverManager.getConnection(URL, USERNAME, PASSWORD);
이 코드만 딸깍해주면 된다.



- DriverManager.getConnection()이 라이브러리에 있는 DB 드라이버를 찾는 과정
JDBC가 제공하는 DriverManager는 라이브러리에 등록된 드라이버 목록을 자동으로 인식한다.

이 모든 드라이버들에게 순서대로 다음 정보를 넘겨서 커넥션을 획득할 수 있는지 확인한다:
    1) URL (예시)	jdbc:h2:tcp://localhost/~/test
    2) 이름, 비밀번호 등 접속에 필요한 추가 정보

여기서 각각의 드라이버는 URL 정보를 체크해서 본인이 처리할 수 있는 요청인지 확인한다. 
예를 들어 URL이 'jdbc:h2'로 시작한다고 하자. 이는 H2 DB에 접근하기 위한 규칙이다.
만약 H2 드라이버에게 이 요청이 오면 본인이 처리할 수 있으므로 실제 DB에 연결해서 커넥션을 획득하고 이 커넥션을 클라이언트에 반환한다. 
만약 MySQL Driver에게 요청이 오면 본인이 처리할 수 없다는 결과를 반환하고, 다음 드라이버에게 순서가 넘어간다.  



- JDBC를 사용하여 DB에 데이터 등록하기(insert into 쿼리)
아래의 코드는 실무에서 직접 사용할 일은 없을 것이다. 그러나 실무에서 아래 코드와 유사한 코드들이 
하부 로직에서 동작하고 있다. 그렇기 때문에 이 코드를 읽고 이해할 수 있어야 한다.

@Slf4j
public class MemberRepositoryV0 {
    
    public Member save(Member member) throws SQLException {
        String sql = "insert into member(member_id, money) values (?, ?)";

        Connection conn = null;
        PreparedStatement pstmt = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, member.getMemberId());
            pstmt.setInt(2, member.getMoney());
            pstmt.executeUpdate();
            return member;
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        } finally {
            close(conn, pstmt, null);
        }
    }

    private void close(Connection conn, Statement stmt, ResultSet rs) {

        if (rs != null) {
            try {
                rs.close();
            } catch (SQLException e) {
                log.info("error", e);
            }
        }

        if (stmt != null) {
            try {
                stmt.close();
            } catch (SQLException e) {
                log.info("error", e);
            }
        }

        if (conn != null) {
            try {
                conn.close();
            } catch (SQLException e) {
                log.info("error", e);
            }
        }
    }

    private Connection getConnection() {
        return DBConnectionUtil.getConnection();
    }
}

save() 메서드는 Member 객체를 입력 받아 그 member의 Id값과 money 값을 설정하고 DB에 저장하는 메서드이다.

* PreparedStatement란?
Statement의 자손 타입으로, '?'를 통한 파라미터 바인딩을 가능하게 해준다.
참고로, SQL Injection 공격을 예방하기 위해서 PreparedStatement를 통한 파라미터 바인딩 방식을 사용해야 한다.
JDBC에서는 DB에 명령을 내리기 위한 sql문 문자열이 필요하다.
insert into member(member_id, money) values (?, ?) 에서 '?' 물음표는 매개변수 자리 표시자이다.
작성된 sql 문자열은 Connection 객체의 preparedStatement() 메서드에 담겨 반환되는 PreparedStatement 객체에 담기게 되고,
그 PreparedStatement에 있는 '?'에 내용이 채워지면 완성된 SQL문이 DB에 전달된다.


* 자원을 안전하게 해제하기 위해 finally 블록을 사용한다. 이는 DB 연결, PreparedStatement, ResultSet 등의 자원을 사용한 후
반드시 해제하여 자원 누수를 방지하는 중요한 관례이다. 


* try 문
conn = getConnection();
    getConnection을 통해 이전에 만들어 둔 DBConnectionUtil을 통해 DB 커넥션을 획득한다.

pstmt = conn.prepareStatement(sql);
    DB에 전달할 SQL과 파라미터로 전달할 데이터들을 준비한다.

pstmt.setString(1, member.getMemberId());
pstmt.setInt(2, member.getMoney());
    SQL의 첫 번째 ?와 두 번째 ?에 값을 지정한다.
    첫 번째 ?는 문자열이므로 pstmt.setString()을 호출하고, 
    두 번째 ?는 Int형 데이터이므로 pstmt.setInt()를 호출한다.

pstmt.executeUpdate();
    Statement를 통해 준비된 SQL을 커넥션을 통해 실제 DB에 전달한다.
    참고로, executeUpdate()는 int를 반환하는데, 이는 영향을 받은 DB row의 갯수를 의미한다.
    본 예제에서는 하나의 row만 등록했으므로 1을 반환할 것이다.


* finally 문
close(conn, pstmt, null);
    쿼리를 실행하고 나면 리소스를 정리해야 한다. 여기서는 Connection, PreparedStatement를 사용했으므로 이들을 정리한다.
    이때, 주의해야 할 점은 선언했을 때의 역순으로 close 해주어야 한다는 것이다.
    그렇기 때문에 close() 메서드를 정의하는 부분을 보면 순서가 rs --> stmt --> conn 순으로 되어 있는 것이다.



- SQLException에 대한 try-catch 블록이 많이 사용되는 이유
SQLException은 JDBC 작업 중 발생할 수 있는 예외를 처리한다. 예를 들면 다음과 같은 상황에서 발생할 수 있다:
    DB 연결 실패
    SQL 문법 오류
    제약 조건 위반
    DB 서버의 네트워크 문제 등

위 예제에서 try문에 담긴 내용들이 모두 SQLException 발생 가능성을 갖고 있기 때문에 try문 안에 작성하는 것이다.
이와 같이 SQL Exception을 catch 해줌으로써 애플리케이션이 예외적으로 종료되지 않게 해줄 수 있다.



- PreparedStatement와 SQL Injection 방어
만약 PreparedStatement를 사용하지 않고 그냥 Statement를 사용한다고 해보자.
    String sql = "SELECT * FROM member WHERE member_id = '" + memberId + "'";
    Connection conn = null;
    Statement stmt = null;

그런데 공격자가 memberId 입력 값으로 {1' OR '1'='1} (양쪽에 홑 따옴표 없음 유의) 라고 입력하면 SQL 쿼리가 다음과 같이 변환된다:
    SELECT * FROM member WHERE member_id = '1' OR '1'='1'

위 쿼리는 항상 참이 되기 때문에 member 테이블의 모든 행이 반환되어 버린다.
공격자는 이와 같은 방법으로 DB의 중요한 정보에 접근하거나, 심지어 데이터를 수정 또는 삭제할 수도 있다.

PreparedStatement는 SQL 쿼리를 사전에 컴파일 하고, 사용자 입력은 '?'에 매개변수로 전달되어 바인딩 함으로써
매개변수와 SQL 쿼리를 분리하여 관리하게 된다. 이렇게 파라미터와 쿼리를 분리함으로써 SQL Injection을 방어하는 것이다.
이제 쿼리문이 로그에 뜰 때 '?'가 뜨는 걸 보면서 SQL Injection 방어를 위한 것이구나 하고 알고 있으면 된다.



- JDBC craete 예제

class MemberRepositoryV0Test {

    MemberRepositoryV0 memberRepository = new MemberRepositoryV0();

    @Test
    void crud() throws SQLException {
        Member member = new Member("memberV1", 10000);
        memberRepository.save(member);
    }
}

위에서 입력한 "memberV1"는 PK값이다. 그렇기 때문에 저 값을 변경하지 않고 테스트 실행을 한 번 더 하면 
JdbcSQLIntegrityConstraintViolationException 예외가 발생한다. 예외 메시지는 아래와 같다: 
Unique index or primary key violation: "PUBLIC.PRIMARY_KEY_8 ON PUBLIC.MEMBER(MEMBER_ID) VALUES ( /* 6 */ 'memberV1' )"; SQL statement:



- JDBC를 사용하여 DB 데이터 조회하기(select 쿼리)

    public Member findById(String memberId) throws SQLException {
        String sql = "select * from member where member_id = ?";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, memberId);

            rs = pstmt.executeQuery();

            if (rs.next()) {
                Member member = new Member();
                member.setMemberId(rs.getString("member_id"));
                member.setMoney(rs.getInt("money"));

                return member;
            } else {
                throw new NoSuchElementException("member not found memberId = " + memberId);
            }
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        } finally {
            close(conn, pstmt, rs);
        }
    }

* ResultSet과 executeQuery()
Connection, PreparedStatement를 통해 DB에 연결하고 쿼리를 전송하는 방법은 save() 때와 같다.
그런데 조회 메서드에는 여기에 더해 ResultSet이 등장한다. 
DB에 조회 요청을 보내면 조회 결과를 담아야 하는데, select 쿼리 결과를 저장하기 위해서 사용하는 것이 바로 ResultSet이다. 
조회 요청을 할 때는 PreparedStatement의 executeQuery() 메서드를 호출하는데, 반환되는 타입이 바로 ResultSet이다.


* if (rs.next()) { ... }
ResultSet의 자료구조는 다음과 같이 생겼다:
member_id	money	<-- cursor의 최초 위치. 가리키는 데이터가 없음. rs.next()를 호출하면 cursor가 아래로 내려감
member1	10000
member2	20000

ResultSet은 내부에 있는 cursor를 이동하여 다음 데이터를 조회한다. 
rs.next()를 호출하면 커서가 다음 데이터로 이동하는 방식이다.
최초의 cursor는 데이터를 가리키고 있지 않기 때문에 rs.next()를 최초 한 번은 호출해야 데이터를 조회할 수 있는 것이다.

만약 next()를 호출했을 때 데이터가 존재할 경우 true를 반환하고, 이때 rs.getString()과 rs.getInt()로 반환받을 수 있다.
만약 next()를 호출했을 때 데이터가 존재하지 않으면 false를 반환하고, 이때 NoSuchElementException 예외를 던진다.
NoSuchElementException 예외는 조회 조건에 맞는 데이터가 존재하지 않을 때 사용하는 예외이다.

데이터가 여러 개 조회할 때는 위와 같이 조건문을 if 문 안에 입력하지 않고 while 문 안에 조건을 입력한다.
지금은 findById() 메서드이기 때문에 데이터를 하나만 조회하기 때문에 if 문을 사용한 것이다.



- save + findById 통합 테스트 코드
먼저 H2 DB에서 delete from member; 를 통해 기존의 데이터를 모두 지워준다.

    @Test
    void crud() throws SQLException {
        // save
        Member member = new Member("memberV0", 10000);
        memberRepository.save(member);

        // findById
        Member findMember = memberRepository.findById(member.getMemberId());
        log.info("findMember = {}", findMember);
        assertThat(findMember).isEqualTo(member);
    }

로그 내용: (앞의 패키지명은 가독성을 위해 생략했음)
DBConnectionUtil -- get connection=conn0: url=jdbc:h2:tcp://localhost/~/test user=SA, class=class org.h2.jdbc.JdbcConnection
DBConnectionUtil -- get connection=conn1: url=jdbc:h2:tcp://localhost/~/test user=SA, class=class org.h2.jdbc.JdbcConnection
MemberRepositoryV0Test -- findMember = Member(memberId=memberV0, money=10000)

참고1) findMember 내용이 "Member(memberId=memberV0, money=10000)" 라고 나오는 이유는
Member 클래스 앞에 롬복에서 제공하는 @Data 애너테이션을 달아주었기 때문이다. 
이 애너테이션은 getter, setter, RequiredArgsConstructor, ToString 등을 제공하는데, 특히 ToString 덕분에 저렇게 나오는 것이다.

참고2) findMember와 member는 == 비교(동일성 비교)를 하면 false이다. 
그런데 isEqualTo() 테스트는 equals 비교(동등성 비교)이기 때문에 통과하는 것이다.
이 역시 @Data 애너테이션에서 equals()와 hashCode()를 자동으로 만들어주었기 때문에 가능한 것이다.

    @Data
    @NoArgsConstructor
    @AllArgsConstructor
    public class Member {

        private String memberId;
        private int money;

    }



- JDBC를 사용하여 DB 데이터 수정하기(update 쿼리)
수정 쿼리는 executeUpdate() 메서드를 사용하기 때문에 등록 로직과 비슷하다.

    public void update(String memberId, int money) throws SQLException {
        String sql = "update member set money = ? where member_id = ?";

        Connection conn = null;
        PreparedStatement pstmt = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setInt(1, money);
            pstmt.setString(2, memberId);
            
            int resultSize = pstmt.executeUpdate();
            log.info("resultSize = {}", resultSize);
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        } finally {
            close(conn, pstmt, null);
        }
    }

SQL문을 보면 '?'가 두 개 나오는데, 이번에는 money가 먼저고, 두 번째가 member_id이다.
그렇기 때문에 pstmt.setInt(1, money);  pstmt.setString(2, memberId); 라고 작성한 것이다.

등록 메서드에서 이미 언급했듯이, pstmt.executeUpdate();는 영향을 받은 row의 수를 반환하기 때문에 
int 타입의 resultSize로 받아서 로깅하는 모습을 볼 수 있다.

그 외 주변 코드들은 템플릿처럼 똑같다.

테스트 코드는 아래와 같다:

    // update: money를 20000으로 수정하는 요청
    memberRepository.update(member.getMemberId(), 20000);
    Member updatedMember = memberRepository.findById(member.getMemberId());
    log.info("updatedMember: {}", updatedMember);
    assertThat(updatedMember.getMoney()).isEqualTo(20000);

테스트 시 유의할 점은 update 후에 updatedMemer로 다시 조회해서 assertThat 해야 한다는 것이다.
왜냐하면 그냥 member는 update 쿼리가 반영되기 전의 객체이기 때문이다.



- JDBC를 사용하여 DB 데이터 삭제하기(delete 쿼리)
삭제 쿼리도 executeUpdate() 메서드를 사용하기 때문에 등록, 수정 로직과 비슷하다.

    public void delete(String memberId) throws SQLException {
        String sql = "delete from member where member_id = ?";

        Connection conn = null;
        PreparedStatement pstmt = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, memberId);
            pstmt.executeUpdate();
        } catch (SQLException e) {
            log.error("db error", e);
            throw e;
        } finally {
            close(conn, pstmt, null);
        }
    }

테스트 코드:
    // delete
    memberRepository.delete(member.getMemberId());
    assertThatThrownBy(() -> memberRepository.findById(member.getMemberId()))
            .isInstanceOf(NoSuchElementException.class);

delete 테스트 코드에서는 삭제 후에 동일한 memberId로 조회를 시도할 때 NoSuchElementException 예외가 발생하는지
확인하는 방식으로 검증한다. 조회 메서드에서 try-catch 블록을 그렇게 해놓았기 때문이다.

이러한 검증 방식은 다른 예외 발생 여부 테스트를 할 때도 유용하니 기억하도록 하자.



- save + findById + update + delete 통합 테스트 코드
    @Test
    void crud() throws SQLException {
        // save
        Member member = new Member("memberV0", 10000);
        memberRepository.save(member);

        // findById
        Member findMember = memberRepository.findById(member.getMemberId());
        log.info("findMember = {}", findMember);
        assertThat(findMember).isEqualTo(member);

        // update: money를 20000으로 수정하는 요청
        memberRepository.update(member.getMemberId(), 20000);
        Member updatedMember = memberRepository.findById(member.getMemberId());
        log.info("updatedMember: {}", updatedMember);
        assertThat(updatedMember.getMoney()).isEqualTo(20000);

        // delete
        memberRepository.delete(member.getMemberId());
        assertThatThrownBy(() -> memberRepository.findById(member.getMemberId()))
                .isInstanceOf(NoSuchElementException.class);
    }

마지막에 회원을 삭제하기 때문에 테스트가 정상적으로 수행된다면 같은 테스트를 반복해서 실행할 수 있다.
그러나, 테스트 중간에 오류가 발생해서 삭제가 안 되면 동일한 memberId(memberV0)가 남아 있기 때문에
테스트 반복이 안 된다. 이 문제는 트랜잭션을 활용하면 해결되며, 자세한 내용은 뒤에서 설명한다.



- Connection Pool
위와 같이 DriverManagre를 사용한 방식은 DB Connection을 매번 획득한다.
DB Connection을 획득하는 과정은 꽤 복잡한데, 다음과 같은 과정들을 거쳐 Connection을 획득한다:
    1) 애플리케이션 로직이 DB 드라이버를 통해 커넥션 조회 요청
    2) DB 드라이버가 DB와 TCP/IP Connection을 연결 (3 way handshake 발생)
    3) DB 드라이버와 DB의 TCP/IP Connection이 연결되면, ID, PW, 그 외 정보들을 DB에 전달
    4) DB는 ID, PW를 통해 내부 인증을 완료하고, 내부에 DB session을 생성
    5) DB는 Connection 생성이 완료되었다고 응답을 보냄
    6) 응답을 받은 DB 드라이버는 Connection 객체를 생성하여 클라이언트(=애플리케이션 서버)에 반환

매 요청마다 위와 같은 과정을 통해 TCP/IP Connection을 새로 만드는 것은
DB는 물론이고 애플리케이션 서버로하여금 시간과 리소스를 소비하게 한다.
특히, 클라이언트의 접근이 활발한 애플리케이션일 경우 응답 속도에 부정적인 영향을 주게 된다.

* 참고: MySQL 계열의 DB는 DB Connection을 생성하는 시간이 수 ms 정도로 상대적으로 빠른 편이지만, 
수 십 ms 이상 걸리는 DB도 있다.

이러한 문제의 해결법은 단순하다: Connection을 미리 생성해두고 필요할 때마다 재사용하기
이 방법은 Connection Pool을 통해 실현된다. 애플리케이션이 시작될 때, Connection Pool은 필요한 만큼의 Connection을 미리 확보하여 보관해둔다. 저장되는 Connection의 개수는 기본값 10개이며, 조절할 수 있다.
Connection Pool에 있는 Connection들은 모두 이미 DB와 TCP/IP 연결도 되어 있고, DB session도 생성되어 있다.
그렇기 때문에 이런 환경에서는 Connection을 연결하는 과정이 생략되고, 즉시 DB에 SQL이 전달될 수 있다.

개발자 입장에서도 복잡할 게 없다. Connection을 요청하면 DB 드라이버를 통해 새로운 Connection을 획득하는 것이 아니라,
Connection Pool에 이미 생성되어 있는 Connection을 객체 참조로 그냥 가져다 쓰기만 하면 된다.
Connection Pool에 Connection을 요청하면 Connection Pool은 자신이 갖고 있는 Connection 중 하나를 반환한다.
그러면 애플리케이션에서는 받은 그 Connection을 사용하여 SQL을 DB에 전달하고 결과를 받아 처리한다.
Connection을 사용한 후에는 재사용할 수 있도록 그 Connection을 종료하지 않고
Connection이 살아있는 상태로 Connection Pool에 다시 반환한다.



- Connection Pool 그 외 정보들
* 서버 당 최대 Connection 수를 제한하는 기능도 있어 DB에 무한정 Connection이 생성되는 것도 막아준다.
* 현재 실무에서 대부분의 경우 Connection Pool 방식을 사용하고 있다.
* 대표적인 Connection Pool 오픈 소스는 commons-dbcp2, tomcat-jdbc pool, HikariCP 등이 있다.
* 스프링 부트 2.0부터는 기본 Connection Pool로 hikariCP가 채택되었다. hikariCP는 사용의 편리함, 안전성 측면에서 이미 검증이 되었기 때문에 실제로 대부분의 실무 프로젝트에서도 레거시 프로젝트가 아닌 이상 hikariCP를 사용하고 있다.



- DataSource
만약 DriverManager 방식으로 Connection을 획득하다가, Connection Pool 방식으로 변경하고 싶을 때는 어떻게 해야 할까?
이러한 변경을 위해서는 Connection을 획득하는 코드 부분들을 모두 변경해주어야 할 것이다.
어떤 Connection Pool에서 다른 Connection Pool로 변경할 때도 마찬가지로 Connection 획득 코드를 변경해주어야 할 것이다.

만약 Connection을 획득하는 방식을 추상화시켜준다면 Connection 획득 방식이 변경되어도 Connection 획득 코드를 변경하지 않아도 될 것이다.
이것을 위해 자바에서는 javax.sql.DataSource라는 인터페이스를 제공한다. 
즉, DataSource는 Connection을 획득하는 방법을 추상화해놓은 인터페이스이다.
DataSource의 핵심 기능은 "Connection 주세요!", 즉 getConnection() 딱 하나라고 봐도 무방하다. 다른 일부 기능도 있는데 크게 중요하진 않다.

그렇기 때문에 개발자는 Connection을 획득할 때 HikariCP나 DBCP2 등에 의존하지 않고, DataSource에 의존하기만 하면 된다.



- 순수 DriverManager 방식 예제
단, DriverManager 방식은 DataSource 인터페이스를 구현하지 않기 때문에 직접 구현 코드를 작성해야 한다.

    @Test
    void driverManager() throws SQLException {
        Connection conn1 = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        Connection conn2 = DriverManager.getConnection(URL, USERNAME, PASSWORD);
        log.info("connection = {}, class = {}", conn1, conn1.getClass());
        log.info("connection = {}, class = {}", conn2, conn2.getClass());
    }

로그 내용(패키지명  생략):
ConnectionTest -- connection = conn0: url=jdbc:h2:tcp://localhost/~/test user=SA, class = class org.h2.jdbc.JdbcConnection
ConnectionTest -- connection = conn1: url=jdbc:h2:tcp://localhost/~/test user=SA, class = class org.h2.jdbc.JdbcConnection
로그의 connection = {} 부분을 보면 위에는 conn0이고, 아래는 conn1이라고 나온다. 이는 서로 다른 Connection이라는 말이다.

그리고, DriverManager.getConnection(URL, USERNAME, PASSWORD); 코드를 보면 알 수 있듯이, Connection을 획득할 때마다
URL, USERNAME, PASSWORD 파라미터를 계속 입력해주어야 한다.




- DriverManagerDataSource 방식 예제: DataSource.getConnection()을 통해 Connection을 받아오는 DriverManager
그런데 만약 DriverManager에서 getConnection()을 DataSource 인터페이스로 적용하고 싶으면 어떻게 해야 할까?
스프링은 DriverManager도 Datasource를 통해서 사용할 수 있도록 DriverManagerDataSource라는 DataSource를 구현한 클래스를 제공한다.

    @Test
    void dataSourceDriverManager() throws SQLException {
        // DriverManagerDataSource - 항상 새로운 커넥션을 획득
        DataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        useDataSource(dataSource);
    }

    private void useDataSource(DataSource dataSource) throws SQLException {
        Connection conn1 = dataSource.getConnection();
        Connection conn2 = dataSource.getConnection();
        log.info("connection = {}, class = {}", conn1, conn1.getClass());
        log.info("connection = {}, class = {}", conn2, conn2.getClass());
    }

DriverManagerDataSource 생성자를 받아주는 객체를 보면 DataSource라고 되어 있다. 이는 DriverManagerDataSource가
DataSource 인터페이스를 구현하도록 설계되었기 때문이다.

로그 내용(패키지명  생략):
ConnectionTest -- connection = conn0: url=jdbc:h2:tcp://localhost/~/test user=SA, class = class org.h2.jdbc.JdbcConnection
ConnectionTest -- connection = conn1: url=jdbc:h2:tcp://localhost/~/test user=SA, class = class org.h2.jdbc.JdbcConnection

기존의 순수 DriverManger 방식과는 다르게, DataSource라는 인터페이스를 통해서 Connection을 가져오는 모습을 볼 수 있다.
그렇기 때문에 getConnection을 할 때마다 URL, USERNAME, PASSWORD을 직접 다 입력해줄 필요가 없다.
DataSource 객체를 생성할 때만 URL, USERNAME, PASSWORD를 입력해주었다면
그 이후부터는 Connection을 획득할 때마다 그냥 dataSource.getConnection()을 호출하기만 하면 된다.

이렇게 설정과 사용을 분리하는 것은 별로 큰 차이 같아 보이지 않을 수 있다.
그러나 이 차이는 굉장히 큰 차이이다.
필요한 설정 정보를 DataSource가 만들어지는 시점에 미리 다 넣어두면 DataSource를 사용하는 곳에서는 dataSource.getConnection()만 호출하면 되므로, 속성들에 의존하지 않아도 되며, 그냥 DataSource만 주입 받아서 getConnection()만 호출하면 된다.
쉽게 말해, Repository가 DataSource에만 의존하고, 이런 속성값들을 몰라도 된다.

실제로 애플리케이션을 개발하다 보면 변경에 더 유연하게 대처하기 위해 설정은 한 곳에서 하지만, 사용은 수많은 곳에서 하게 된다. 
사용하는 곳마다 설정까지 일일히 다 하게 되면 그만큼 코드도 늘어나고 유지보수도 어려워지기 때문에
이러한 분리는 사실상 굉장히 큰 차이를 만들어내는 것이다.



- Connection Pool 사용 예제

    @Test
    void dataSourceConnectionPool() throws SQLException, InterruptedException {
        // Connection Pooling
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(URL);
        dataSource.setUsername(USERNAME);
        dataSource.setPassword(PASSWORD);
        dataSource.setMaximumPoolSize(10);
        dataSource.setPoolName("WoongjinPool");

        useDataSource(dataSource);
        Thread.sleep(1000);
    }

HikariCP 커넥션 풀을 사용하는 모습이다. HikariDataSource는 DataSource 인터페이스의 구현체이다.
위와 같이 DataSource는 다양한 메서드를 지원한다: 
    setJdbcUrl, setUsername, setPassword, setMaximunPoolSize, setPoolName 등...

위 테스트를 실행하면 'connection adder'라는 Connection Pool 전용 쓰레드가 Connection Pool에 Connection을 10개(conn0 ~ conn9) 채운다.
WoongjinPool connection adder] MyPool - Added connection conn0: url=jdbc:h2:..user=SA
WoongjinPool connection adder] MyPool - Added connection conn1: url=jdbc:h2:..user=SA
WoongjinPool connection adder] MyPool - Added connection conn2: url=jdbc:h2:..user=SA
WoongjinPool connection adder] MyPool - Added connection conn3: url=jdbc:h2:..user=SA
WoongjinPool connection adder] MyPool - Added connection conn4: url=jdbc:h2:..user=SA
...
WoongjinPool connection adder] MyPool - Added connection conn9: url=jdbc:h2:..user=SA


그리고 이 useDataSource 메서드 내부 로직으로 인해 Connection을 두 개 얻는다:

    private void useDataSource(DataSource dataSource) throws SQLException {
        Connection conn1 = dataSource.getConnection();
        Connection conn2 = dataSource.getConnection();
        log.info("connection = {}, class = {}", conn1, conn1.getClass());
        log.info("connection = {}, class = {}", conn2, conn2.getClass());
    }

ConnectionTest --connection = HikariProxyConnection@932582590 wrapping conn0: url=jdbc:h2:tcp://localhost/~/test user=SA, class = class com.zaxxer.hikari.pool.HikariProxyConnection
ConnectionTest --connection = HikariProxyConnection@1507118393 wrapping conn1: url=jdbc:h2:tcp://localhost/~/test user=SA, class = class com.zaxxer.hikari.pool.HikariProxyConnection

그리고 로그를 보면 [main] DEBUG com.zaxxer.hikari.HikariConfig 로 시작하는 로그들이 있다.
이는 HikariConfig의 기본 설정값들을 포함하여 위에서 setter를 통해 설정해준 설정값들이 나오는 것이다.

그리고 로그에는 이런 내용들도 나온다: total=10, active=2, idle=8, waiting=0
이는 활성화 된 커넥션이 2개이고, 대기중인 커넥션이 8개라는 의미이다.



- Connection Pooling에 별도의 쓰레드가 사용되는 이유
Connection Pool에 Connection을 채우는 것은 상대적으로 오래 걸린다. 애플리케이션을 실행할 때 Connection Pool을 채울 때까지 마냥 대기하고 있다면 애플리케이션 실행 시간이 늦어질 것이다. 그렇기 때문에 별도의 쓰레드를 사용하여 Connection Pool을 채워야 애플리케이션 실행 시간에 영향을 덜 주게 된다.



- 만약 Connection Pool의 Connection 수보다 많은 Connection이 요청되면?
그때는 wating 값이 증가한다.
    ex) 11개의 커넥션이 요청될 때 로그
        total=10, active=10, idle=0, waiting=1



- DataSource 사용해보기
MemberRepositoryV1 이라는 새로운 리포지토리 클래스를 생성하고 V0의 코드를 복붙한다.
일부 코드를 DataSource 사용 예제에 맞게 수정할 것이다.

@RequiredArgsConstructor 애너테이션과 private final DataSource dataSource; 선언을 통해 Datasource를 주입 받는다.
그리고 JdbcUtils를 사용한다. 이에 따라 close()와 getConnection() 코드가 아래와 같이 깔끔하게 변경된다: 

    private void close(Connection conn, Statement stmt, ResultSet rs) {
        JdbcUtils.closeResultSet(rs);
        JdbcUtils.closeStatement(stmt);
        JdbcUtils.closeConnection(conn);
    }

    private Connection getConnection() throws SQLException {
        Connection conn = dataSource.getConnection();
        log.info("get connection = {}, class = {}", conn, conn.getClass());
        return conn;
    }

JdbcUtils는 스프링에서 제공하는 추상 클래스이며, JDBC를 편리하게 다룰 수 있게 해준다.
본 실습에서는 Connection을 편리하게 닫게 해주는 기능들을 사용하고 있다.

놀랍게도 이 코드들 외에는 V0이랑 비교해서 변경사항이 없다.
그만큼 DataSource가 필요한 기능들을 잘 추상화 해놓았다는 뜻이다.



- DataSource를 사용한 테스트: MemberRepositoryV1Test.java
crud() 테스트 코드는 아무런 변경을 하지 않고 다음과 같은 변경 사항만 생긴다:

    MemberRepositoryV1 memberRepository;

    @BeforeEach
    void beforeEach() {
        // 기본 DriverManager - 항상 새로운 커넥션 획득
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        memberRepository = new MemberRepositoryV1(dataSource);
    }

이 상황에서 crud()를 실행해보면 다음과 같은 로그가 출력된다:
    MemberRepositoryV1 --get connection = conn0: ...
    MemberRepositoryV1 --get connection = conn1: ...
    MemberRepositoryV1 --get connection = conn2: ...
       ... 
    MemberRepositoryV1 --get connection = conn5: ...

즉, 매 요청마다 항상 새로운 커넥션을 획득하는 방식이다. 이는 DriverManagerDataSource를 사용하고 있기 때문이다.
이렇게 되면 성능이 느릴 것이다. DriverManager 방식의 한계이다.

이제 여기서 Connection Pool 방식으로 바꿔보자.
    @BeforeEach
    void beforeEach() {
        // Connection Pooling 방식
        HikariDataSource dataSource = new HikariDataSource();
        dataSource.setJdbcUrl(URL);
        dataSource.setUsername(USERNAME);
        dataSource.setPassword(PASSWORD);
        
        memberRepository = new MemberRepositoryV1(dataSource);
    }

beforeEach 코드가 위와 같이 바뀌었다. 다시 crud()를 실행하면 로그가 다음과 같이 뜬다:
    MemberRepositoryV1 --get connection = HikariProxyConnection@69329761 wrapping conn0: ...
    MemberRepositoryV1 --get connection = HikariProxyConnection@1499840045 wrapping conn0: ...
    MemberRepositoryV1 --get connection = HikariProxyConnection@1105628551 wrapping conn0: ...
    MemberRepositoryV1 --get connection = HikariProxyConnection@1241480588 wrapping conn0: ...
    MemberRepositoryV1 --get connection = HikariProxyConnection@1234586997 wrapping conn0: ...
    MemberRepositoryV1 --get connection = HikariProxyConnection@729218894 wrapping conn0: ...
Connection 객체는 다른데 conn0만 사용되는 모습을 볼 수 있다. 이는 Connection Pool 에 있는 Connection을 재활용하기 때문이다.
'wrapping' 이라는 말은 HikariProxyConnection이라는 프록시 객체가 실제 JDBC Connection 객체를 wrapping 한다는 의미이다.
위 로그에서 프록시 객체들이 서로 다르지만 그 안에 감싸고 있는(wrapping) 실제 JDBC Connection 객체는 conn0으로 똑같다.
또, Connection Pool 방식에서는 conn.close()를 하면 Connection이 사라지는 게 아니라 Pool로 다시 반환되어 idle 상태로 되고,
프록시 Connection 객체는 사라진다.
만약 멀티 쓰레드 환경에서 다른 Connection이 close 되기 전에 요청을 하면 conn0 말고 다른 Connection도 사용될 것이다.

위와 같이, DriverManagerDataSource를 HikariDataSource로 변경해도 CRUD와 관련된 코드들은 전혀 변경 사항이 없었다.
이것이 가능한 이유는 두 경우 모두 DataSource라는 추상화된 인터페이스에 공통적으로 의존하고 있었기 때문이다.
인터페이스 방식 덕분에 더 좋은 구현체가 나오면 손쉽게 갈아끼울 수 있어서 오픈 소스 생태계도 활성화될 수 있는 것이다.



- 트랜잭션 ACID 개념
트랜잭션에서 모든 작업을 성공하여 DB에 정상 반영하는 것을 commit 이라고 하고,
작업 중 하나라도 문제가 생겨 작업하기 전으로 돌아가는 것을 rollback이라 한다.
트랜잭션을 통해 모든 작업이 성공해야 commit 하도록 하여 데이터가 안전하게 관리될 수 있다.
트랜잭션 ACID는 트랜잭션의 특징들을 줄여서 표현한 것이다: Atomicity, Consistency, Isolation, Durability

* Atomicity 원자성
    한 트랜잭션 내에서 실행한 작업들은 마치 하나의 작업인 것처럼 모두 성공하거나 모두 실패한다.
    원자는 '분리되지 않음'을 상징하는 단어이기 때문에 작업들이 하나의 트랜잭션 안에 묶여 있다는 의미로
    원자성이라는 이름이 붙은 것이다.

* Consistency 일관성
    모든 트랜잭션은 일관성 있는 DB 상태를 유지해야 한다. 예를 들어 DB에서 정한 무결성 제약 조건을 항상 만족해야 한다.

* Isolation 격리성
    동시에 실행되는 트랜잭션들이 서로에게 영향을 주지 않도록 격리한다.
    예를 들어 동시에 같은 데이터를 수정하거나 삭제하지 못하도록 트랜잭션 간에 서로 격리시킨다.
    격리성은 동시성과 관련된 성능 이슈로 인해 trasaction Isolation level을 선택할 수 있다.

* Durability 지속성
    트랜잭션을 성공적으로 끝내면 그 결과가 항상 기록되어야 한다. 중간에 시스템이 문제가 생겨도
    DB 로그 등을 사용하여 성공한 트랜잭션 내용을 복구해야 한다.



- Transaction Isolation Level 트랜잭션 격리 수준
트랜잭션의 격리성을 완벽히 보장하려면 트랜잭션을 거의 순서대로 실행해야 한다. 이렇게 하면 동시 처리 성능이 매우 나빠진다. 
즉, 병렬 처리에 문제가 생긴다. 이런 문제로 인해 ANSI 표준은 트랜잭션의 격리 수준을 4단계로 나누어 정의했다.
그리고 DB마다 기본값으로 설정된 격리 수준이 다르다.
가장 낮은 격리수준부터 설명하면 다음과 같다:

1) READ UNCOMMITTED
가장 낮은 격리수준. 한 트랜잭션에서 변경한 데이터가 커밋되지 않았더라도 다른 트랜잭션에서 읽을 수 있다(Dirty Read).
속도는 가장 빠르지만 변경 중인 데이터를 읽게되어 불일치가 발생할 수 있다. 

2) READ COMMITED
한 트랜잭션에서 커밋된 데이터만 다른 트랜잭션에서 읽을 수 있다.
READ UNCOMMITTED보다 일관성이 높으나, 여전히 일부 일관성 문제 발생 여지는 남아있다.

3) REPEATABLE READ
한 트랜잭션이 읽은 데이터는 해당 트랜잭션이 완료될 때까지 다른 트랜잭션에서 수정할 수 없다.
일관성이 한 단계 더 높아졌으나, 성능이 약간 저하되었다.

4) SERIALIZABLE
가장 높은 격리 수준. 모든 트랜잭션을 순차적으로 실행하는 것처럼 보이게 한다. 
한 트랜잭션이 완료되기 전까지 다른 트랜잭션은 동일한 데이터를 읽거나 쓸 수 없다.
일관성이 가장 높으나, 동시에 처리할 수 있는 트랜잭션 수가 줄어들어 성능은 가장 낮다.

* MySQL은 기본값으로 REPEATABLE READ를 사용한다.
* Oracle은 기본값으로 READ COMMITTED를 사용한다.
본 강의에서는 READ COMMITTED 격리 수준으로 설명한다.

트랜잭션의 격리 수준은 DB 설정을 조정함으로써 일괄적으로 변경할 수도 있고,
특정 트랜잭션에 대해서만 설정할 수도 있다.



- DB 연결 구조와 DB 세션
* 기본 구조
클라이언트가 애플리케이션 서버에 접근하면 DB와의 Connection이 생긴다.
Connection이 생기면 DB 내부에서 DB session을 만든다.
이제부터 해당 Connection에 대한 모든 요청은 이 DB session을 통해 실행된다.

DB session은 트랜잭션을 시작하고, SQL을 실행하고, 커밋 또는 롤백을 통해 트랜잭션을 종료한다.
그리고 이후에 새로운 트랜잭션을 다시 시작할 수 있다.
사용자가 Connection을 닫거나, 또는 DBA가 세션을 강제로 종료하면 세션은 종료된다.

Connection Pool 환경에서도 마찬가지다. 예를 들어 10개의 Connection이 있다고 하면,
Connection과 그 Connection에 대한 DB session 모두 각각 10개씩 미리 만들어지고 이미 연결되어 있다.
클라이언트가 Connection을 새롭게 요청하더라도 이미 연결되어 있는 Connection을 가져다 쓰는 것이다.



- 트랜잭션의 상태: '임시'와 '완료'
실제로 DB 내부에서는 데이터의 상태를 한 트랜잭션 내에서 '임시'와 '완료'로 관리하고 있다. 
트랜잭션 내에서는 commit을 호출하기 전까지는 데이터가 '임시' 상태이고, 
트랜잭션 내에서의 작업을 완전히 DB에 반영하려면('완료') commit을 해야 하고, 결과에 반영하지 않으려면 rollback을 해야 한다.

'임시' 상태의 데이터, 즉 아직 commit 되지 않은 변경(등록, 수정, 삭제) 데이터들은 해당 트랜잭션을 시작한 세션 사용자에게만 보인다.
당연히 다른 세션 사용자에게는 '임시' 상태의 변경 데이터가 보이지 않는다. 이렇게 함으로 데이터 정합성을 유지한다.
* 앞으로 '등록, 수정, 삭제'를 통틀어 '변경'이라는 단어로 표현할 것이다.

만약 commit이 되지 않은 데이터를 다른 세션에서도 조회할 수 있다면,
그 상태에서 만약 롤백을 해버리면 데이터 정합성에 큰 문제가 생기고,
실제 서비스에서 돈이 오고가거나 중요한 정보가 오고가는 곳에서는 심각한 문제가 발생할 수 있다.



- 자동커밋과 수동커밋
자동커밋은 하나의 쿼리를 실행한 직후에 바로 커밋을 호출한다. 그렇기 때문에 수동으로 커밋을 호출하지 않는 편리함이 있다.
그러나 이는 트랜잭션이 제공하는 롤백 기능을 사용할 수 없게 되는 문제가 있다.
자동커밋을 활성화시키는 SQL문은 다음과 같다:
    set autocommit true;

수동커밋은 이와 반대이며, 수동커밋으로 설정하는 SQL문은 다음과 같다:
    set autocommit false;
사실 애플리케이션에서 @Transactional 애너테이션을 달아줄 때 수동 커밋 모드로 바뀐다.
수동커밋 모드로 변경되는 시점이 바로 '트랜잭션이 시작'되는 시점이라 이해해도 무방하다.

수동커밋에서는 SQL문을 보낸 후 commit 또는 rollback 명령어를 수행해야 한다. 명령어는 다음과 같다:
    commit;
    rollback;

자동커밋과 수동커밋은 설정 사항은 해당 세션 내에서 중간에 변경해주기 전까지 계속 유지된다.



- DB Lock
한 세션에서 트랜잭션을 시작하면 트랜잭션이 끝나기 전까지는 다른 세션에서 해당 데이터를 수정할 수 없게 막아야 한다.
이를 위해 DB에는 Lock이라는 개념이 있다. 한 세션에서 특정 데이터에 대해 트랜잭션을 걸면, 그 세션은 그 데이터들에 대한 Lock을 획득한다.
이 Lock을 획득해야 데이터를 변경할 수 있다. 그렇기 때문에 현재 그 세션만 해당 데이터를 변경할 수 있는 상태다.
다른 세션에서 변경을 시도하려 해도 해당 데이터에 대한 Lock이 없으므로 해당 데이터를 변경할 수 없다.

실제로, H2 Console 브라우저를 2개 열고 동일한 tuple에 대해 일부 내용을 하나에서 먼저 수정하고 commit이나 rollback을 하기 전까지는
다른 세션에서 변경이 당장은 먹히지 않고, Lock을 획득할 때까지 대기상태가 된다.
처음 세션에서 commit 또는 rollback을 하면 Lock을 반납하게 되고, 그때 대기하던 세션에서 Lock을 획득하여 쿼리를 수행한다.
이 대기 시간은 무한정 지속되는 것은 아니고, 정해진 대기 시간이 지나면 Lock Timeout 에러가 발생한다.



- Lock Timeout
락 타임아웃 시간은 설정해줄 수 있는데, 명령어는 다음과 같다: 
    set lock_timeout 10000;
숫자는 ms 단위이다. 그러므로 예시에서는 10초를 의미하고 있다.

세션1에서 Lock을 반납하지 않아서 세션2에서 계속 대기하다가 락 타임아웃이 되면 다음과 같은 메시지가 출력된다:
    Timeout trying to lock table {0}; SQL statement:
    update member set money=10000 - 2000 where member_id = 'memberA' [50200-200]
    HYT00/50200



- 조회할 때 Lock을 획득해야 하는 경우: select ~ for update
DB마다 다르지만 일반적으로 조회는 Lock을 사용하지 않는다. 그러나 데이터를 조회할 때도 락을 획득하고 싶을 때가 있다.
예를 들어 애플리케이션 로직에서 특정 유저A의 금액을 조회한 후 이 금액 정보로 계산을 수행한다고 하자.
근데 이 계산이 돈과 관련된 매우 중요한 계산이어서 계산이 완료될 때까지 다른 곳에서 유저A의 금액을 건드리면 안 된다고 하자.
이럴 때는 조회를 사용한다고 해도 Lock을 획득해서 다른 곳에서의 변경을 막아야 할 것이다. 
    ex) 새벽 특정 시간에 모바일 뱅킹을 못하도록 시스템에서 막아버리는 경우

이렇게 조회할 때 Lock을 획득하고 싶을 땐 'select ~ for update' 구문을 사용한다.
    ex) select * from member where member_id='memberA' for update;
이렇게 하면 조회 시점에 Lock을 가져가버리기 때문에 다른 세션에서 해당 데이터를 변경할 수 없다.
* 참고: Lock이 걸린 동안 변경이 안 된다는 것이지, 트랜잭션이 시작하기 전 상태의 데이터를 조회하는 건 당연히 가능함.

실제로, 한 세션에서 select ~ for update 했을 때, 다른 세션에서 update 쿼리를 날리면 이런 오류 메시지가 뜬다:
    Timeout trying to lock table {0}; SQL statement:
    update member set money=500 where member_id = 'memberA' [50200-214] HYT00/50200 
이때는 update 쿼리가 아예 먹히지 않기 때문에 해당 데이터를 조회해보면 update 쿼리를 보내기 전 상태의 데이터 그대로이다.

이 오류 메시지가 뜨려면 몇 초 정도 걸리는데, 오류 메시지가 뜨기 전에 재빠르게 세션1에서 commit; 해주면
정상적으로 update 쿼리가 반영된다.



- 애플리케이션에서 트랜잭션 학습내용 적용해보기1: 트랜잭션이 없을 때
전체 코드 참고:
https://github.com/wjcho0303/SpringDB1/commit/cffe27651f99a40d7449d9bc00497ee201bd7485

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Member fromMember = memberRepository.findById(fromId);
        Member toMember = memberRepository.findById(toId);

        memberRepository.update(fromId, fromMember.getMoney() - money);
        validate(toMember); // 학습을 위한 의도적 예외 발생 코드
        memberRepository.update(toId, toMember.getMoney() + money);

    }

    private static void validate(Member toMember) {
        if (toMember.getMemberId().equals("ex")) {
            throw new IllegalStateException("이체 중 예외 발생");
        }
    }



    @Test
    @DisplayName("이체 중 예외 발생")
    void accountTransferEx() throws SQLException {
        // given (준비된 데이터)
        Member memberA = new Member(MEMBER_A, 10000);
        Member memberEx = new Member(MEMBER_EX, 10000);
        memberRepository.save(memberA);
        memberRepository.save(memberEx);

        // when (수행한 작업)
        assertThatThrownBy(() -> memberService.accountTransfer(memberA.getMemberId(), memberEx.getMemberId(), 2000))
                .isInstanceOf(IllegalStateException.class);

        // then (검증)
        // 로직 중간에 예외를 터트렸기 때문에 memberA의 돈만 빠지고 memberEx에게는 돈이 안 들어와야 함
        Member findMemberA = memberRepository.findById(memberA.getMemberId());
        Member findMemberEx = memberRepository.findById(memberEx.getMemberId());
        assertThat(findMemberA.getMoney()).isEqualTo(8000);
        assertThat(findMemberEx.getMoney()).isEqualTo(10000);
    }

자동커밋 모드로 설정하고, 일부러 거래 상황 도중에 예외가 발생하는 테스트 케이스를 작성하였다.
거래 도중에 예외가 발생했는데도 불구하고 memberA의 출금만 정상처리 되고, memberEx의 입금은 처리가 되지 않아
문제가 발생하였다. 예외가 발생하면 memberA의 출금까지도 막혔어야 한다.
이는 자동커밋 모드에서 진행되었기 때문에 발생한 사태로, 현실에서 이런 일이 벌어지면 큰 일 날 것이다.



- 트랜잭션을 걸어주는 시점에 대해: @Service
트랜잭션을 적용해보자. 그런데, 트랜잭션은 어느 시점에 걸어줘야 할까? 답은 Service 계층이다.
트랜잭션은 여러 DB 작업을 하나의 단위로 묶어주는 개념이다. 이 단위 내에서 비즈니스 로직 내의 모든 DB 작업이 성공해야만
DB에 최종적으로 반영시키게 해야 한다. 중간에 하나라도 실패하면 모든 DB 작업을 롤백시켜야 한다.
트랜잭션은 일반적으로 비즈니스 로직 단위에 대응하며, 이러한 비즈니스 로직은 서비스 계층에서 구현된다.
그렇기 때문에 Repository 계층이 아닌 Service 계층에 @Transactional을 걸어줘야 한다.

만약 Repository 계층에 @Transactional을 적용하면 각각의 데이터 접근 메서드가 독립적인 트랜잭션으로 처리되어 버린다.
이렇게 되면 하나의 비즈니스 로직이 여러 개의 트랜잭션으로 쪼개져 버리기 때문에 트랜잭션의 원자성에 위배된다.
만약 Service 계층에서 하나의 비즈니스 로직 메서드에서 여러 개의 Repository의 메서드를 호출하는 로직이 있다고 하자.
이 비즈니스 로직 메서드 중간에 예외가 터졌다고 하자. 그러면 그 메서드 내에 포함된 모든 Repository 메서드들의 작업이 취소되어야 한다.
그런데 Repository 단위로 @Transactional이 걸려있다면 일부는 이미 commit이 되버리기 때문에 서비스 사고 사태가 발생할 것이다.
위에서 살펴본 memberA의 경우처럼 말이다.
이렇게, Repository에 @Transactional을 걸어주는 건 그냥 트랜잭션을 사용하지 않는 거나 마찬가지다.



- 애플리케이션에서 트랜잭션 학습내용 적용해보기2: 트랜잭션이 적용된 경우
Service 계층에 트랜잭션을 걸어줘야 한다는 것은 알았다.
그런데 트랜잭션을 시작한다는 것은 session이 있다는 것이고, session이 있다는 것은 Connection이 있다는 것이다.
그리고 트랜잭션을 사용하는 동안에는 같은 Connection 및 session을 유지해야 한다.

예를 들어 accountTransfer() 라는 메서드 내부에는 이런 로직이 있다:
    memberRepository.update(fromId, fromMember.getMoney() - money);
    validate(toMember); // 학습을 위한 의도적 예외 발생 코드
    memberRepository.update(toId, toMember.getMoney() + money);
update 쿼리가 두 개가 있다. 이 update 쿼리 두 개를 한 Connection 내에서(동일한 session) 다 해야 한다는 것이다.

그렇다면 애플리케이션에서 같은 Connection을 유지하려면 어떻게 해줘야 하나?
가장 단순한 방법은 Connection을 파라미터로 전달하여 같은 Connection이 사용되도록 유지해주는 것이다.

MemberRepositoryV1을 복사하여 MemberRepositoryV2를 만들고, 아래와 같은 수정을 해주었다.
Repository에서 직접 getConnection()을 하지 않고, Service로부터 Connection을 파라미터로 받고 있다.

    public Member findById(Connection conn, String memberId) throws SQLException {
        ...
        finally {
            // Connection 닫는 것을 Service에 위임한다
            JdbcUtils.closeResultSet(rs);
            JdbcUtils.closeStatement(pstmt);
        }
    }

    public void update(Connection conn, String memberId, int money) throws SQLException {
        ...
        finally {
            // Connection 닫는 것을 Service에 위임한다
            JdbcUtils.closeStatement(pstmt);
        }
    }

위와 같이 Repository에서 getConnection을 해서도 안 되고, JdbcUtils.closeConnection(conn)를 해서도 안 된다.
왜냐하면 트랜잭션의 단위가 Service 메서드의 단위로 확장되었기 때문에 Connection을 획득하는 것도 Service에 위임해야 하고,
비즈니스 로직이 끝나기도 전에 Repository에서 Connection을 닫아버리면 안 되기 때문이다.

위 RepositoryV2에 맞는 ServiceV2도 만들었다. Service에서 Connection을 얻어와야 하므로 먼저 DataSource를 DI 받고,
V1에 의존하던 Repository도 V2로 수정한다.

    private final DataSource dataSource;
    private final MemberRepositoryV2 memberRepository;

수정된 accountTransfer() 메서드 로직은 다음과 같다:

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Connection conn = dataSource.getConnection();
        try {
            // 수동커밋 모드 설정 = 트랜잭션 시작
            conn.setAutoCommit(false);

            // 비즈니스 로직 수행: 파라미터에 Connection 전달
            Member fromMember = memberRepository.findById(conn, fromId);
            Member toMember = memberRepository.findById(conn, toId);

            memberRepository.update(conn, fromId, fromMember.getMoney() - money);
            validate(toMember); // 학습을 위한 의도적 예외 발생 코드
            memberRepository.update(conn, toId, toMember.getMoney() + money);

            // 성공 시 커밋
            conn.commit();
        } catch (Exception e) {
            // 실패 시 롤백
            conn.rollback();
            throw new IllegalStateException(e);
        } finally {
            // Connection 릴리즈
            if (conn != null) {
                try {
                    // 커넥션 풀을 고려하여, 자동커밋 모드로 다시 원복시킨 후 close 해야 한다.
                    conn.setAutoCommit(true);
                    conn.close();
                } catch (Exception e) {
                    log.info("error", e);
                }
            }
        }
    }

코드가 전체적으로 상당히 복잡하지만 핵심적인 부분을 짚어보면 다음과 같다: 
* DI 받은 DataSource를 이용해서 getConnection()을 하여 Connection을 획득하는 모습을 볼 수 있다.
* 수동커밋을 위해 conn.setAutoCommit(false); 를 하고, 후에 Connection을 닫기 전에 다시 true로 바꿔주는 모습을 볼 수 있다.
* 비즈니스 로직을 try 블록 안에 넣고, 예외 발생 시 conn.rollback() 메서드를 호출하는 모습을 볼 수 있다.
  이때, repositry의 메서드마다 conn 파라미터를 추가로 입력하도록 수정하였다.

* 실제 코드에선 비즈니스 로직 부분과 finally 내부 코드를 각각 accountTransferBizLogic()과 release() 메서드로 extract해놓았다...
너무 지저분해서...

    // 비즈니스 로직 수행: 파라미터에 Connection 전달
    accountTransferBizLogic(conn, toId, money, fromId);

    finally {
        // Connection 릴리즈
        release(conn);
    }



- 트랜잭션 완료 후 다시 conn.setAutoCommit(true);를 해줘야 하는 이유
    * 커넥션을 다시 풀에 반환하기 전에 상태를 기본값으로 초기화하여, 다음 사용자가 예상하는 상태로 만들어줘야 한다.
    * 수동 커밋 모드에서 커밋이나 롤백이 수행되지 않으면, 트랜잭션이 계속 열린 상태로 남게 된다.
      그렇게 되면 다른 트랜잭션과 충돌이 일어날 수 있다.



- 테스트 예제
테스트는 의존성 주입 받는 부분 외에는 변경할 곳이 없다.
다만, 로그를 통해 실제로 Connection을 재활용하는지 확인해본다.

    // when (수행한 작업)
    log.info("START TX");
    memberService.accountTransfer(memberA.getMemberId(), memberB.getMemberId(), 2000);
    log.info("END TX");

다음과 같이 로그가 남게 코드를 작성하고, 실행 시켜보면 다음과 같이 로그가 출력된다:
INFO  h.s.repository.MemberRepositoryV2 --get connection = conn1: url=jdbc:h2:tcp://localhost/~/test user=SA, ... 
INFO  h.s.service.MemberServiceV2Test --START TX
DEBUG o.s.j.d.DriverManagerDataSource --Creating new JDBC DriverManager Connection to [jdbc:h2:tcp://localhost/~/test]
INFO  h.s.repository.MemberRepositoryV2 --resultSize = 1
INFO  h.s.repository.MemberRepositoryV2 --resultSize = 1
INFO  h.s.service.MemberServiceV2Test --END TX

위에서 get connection을 통해 conn1을 받은 후 TX 내에서 getConnection 하는 부분이 없다.
이는 conn1을 재사용했다는 뜻이다.

예외 발생 테스트도 아래의 검증 부분 기댓값만 수정하고 테스트하면 통과한다.

    assertThat(findMemberA.getMoney()).isEqualTo(10000);
    assertThat(findMemberEx.getMoney()).isEqualTo(10000);

왜냐하면 예외가 터지면 rollback() 메서드를 호출하게 했으므로 비즈니스 로직을 수행하기 전 상태가 되기 때문이다.



