- 서비스 계층의 순수성
서비스 계층은 핵심 비즈니스 로직이 들어있는 곳이기 때문에 시간이 흘러서 UI와 관련된 부분이 변하고, 데이터 저장 기술이 변하더라도 비즈니스 로직은 최대한 변경없이 유지되어야 한다. 그러므로 서비스 계층을 특정 기술에 종속적이지 않게 개발해야 한다.

프레젠테이션 계층은 클라이언트가 접근하는 UI와 관련된 기술인 웹, 서블릿, HTTP와 관련된 부분을 담당해준다. 
그래서 서비스 계층을 이런 UI와 관련된 기술로부터 보호해준다. 예를 들어 HTTP API를 사용하다가 GRPC 같은 기술로 변경해도
프레젠테이션 계층의 코드만 변하고, 서비스 계층은 변경하지 않아도 된다.

데이터 접근 계층도 마찬가지다. JDBC, JPA와 같은 구체적인 데이터 접근 기술로부터 서비스 계층을 보호한다.
물론 서비스 계층에서 데이터 접근 계층을 직접 접근하게 하지 않고, 인터페이스를 제공하여 서비스 계층이 이 인터페이스에 의존하는 것이 좋다.

서비스 계층은 가급적이면 특정 기술에 종속되지 않아야 비즈니스 로직을 유지보수 하기도 쉽고, 테스트하기도 쉽다.

* 서비스 계층 코드 살펴보기: MemberServiceV1
MemberServiceV1의 경우 특정 기술에 의존적이지 않고 대부분 순수한 자바 코드로 작성되어 있기 때문에 순수한 편이라 볼 수 있다.
물론 SQLException을 throws 하는 부분이 있는데, 이는 JDBC에 종속적인 예외라는 점에서 이 부분은 memberRepository에서 해결해야 한다.
또, MemberRepositoryV1이라는 구체적인 구현체 클래스에 의존하고 있는데, 이는 향후 인터페이스를 도입하는 것이 좋다.

* 서비스 계층 코드 살펴보기: MemberServiceV2
DataSource, Connection, 그리고 Transaction 관련 코드들은 JDBC와 관련된 코드들이다. 
Transaction은 비즈니스 로직이 있는 서비스 계층에서 시작하는 것이 좋다고 위에서 언급했지만, 
이렇게 비즈니스 로직 외의 다른 기술들의 코드가 더 많은 비율을 차지하며 섞여 있으면 비즈니스 로직에 대한 유지보수를 어렵게 한다.
이렇게 작성되어 있으면 현재는 JDBC 기준으로 코드가 작성되어 있는데, JPA를 적용하기 위해 많은 서비스 계층의 코드가 수정되어야 한다.



- 현재 서비스 계층 코드의 문제점들 정리
트랜잭션 문제, 예외 누수 문제, JDBC 코드 반복 문제

1) 트랜잭션 문제
    * 트랜잭션을 적용하기 위해 JDBC 구현 기술이 서비스 계층에 누수됨
    * 데이터 접근 계층에 JDBC 코드를 몰아주어야 함. 이때, 데이터 접근 계층의 기술 변경을 고려하여 인터페이스를 제공하는 것이 좋음
    * 트랜잭션 동기화 문제. 같은 트랜잭션을 유지하기 위해 Connection을 파라미터로 넘겨야 하는 상황
    * 트랜잭션 적용을 위한 try-catch-finally 코드의 반복

2) 예외 누수 문제
    * JDBC 구현 기술의 예외(SQLException)가 서비스 계층으로 전파되고 있음. SQLException은 체크 예외이기 때문에
      데이터 접근 계층을 호출한 서비스 계층에서 해당 예외를 잡아서 처리하거나, 명시적으로 throws를 통해서 다시 밖으로 던지고 있음
    * SQLException은 JDBC 전용 기술임. 향후 JPA나 다른 데이터 접근 기술을 사용하면 그에 맞는 예외로 다시 변경해야 하는 상황

3) JDBC 코드 반복 문제

스프링은 서비스 계층을 순수하게 유지하면서, 위에서 언급한 문제들을 해결할 수 있는 기술들을 제공하고 있다.



- 스프링에서 제공하는 트랜잭션 추상화
앞에서 살펴본 트랜잭션을 시작하는 코드인 conn.setAutoCommit(false); 는 사실 JDBC 코드이다.
만약 JPA로 트랜잭션을 시작하면 보통 tx.begin(); 이렇게 코드가 작성된다.
만약 데이터 접근 기술이 JDBC에서 JPA로 변경된다면 이 코드들을 싹 다 바꿔줘야 할 것이다.

코드 변경에 유연하게 대처하는 방법 중 대표적인 것 하나는 바로 인터페이스를 통해 추상화된 메서드를 사용하는 것이다.
서비스 계층에서 특정 트랜잭션 기술에 의존하지 않고 추상화된 인터페이스에 의존하게 한 후, 원하는 구현체만 DI를 통해서 주입하면 된다.
그렇게 하면 서비스는 인터페이스에 의존하고 DI를 사용하여 OCP 원칙을 지키면서도 특정 기술에 의존한 코드를 작성하지 않을 수 있다.

스프링은 이미 트랜잭션 추상화 인터페이스를 제공하고 있으며, 심지어 데이터 접근 기술에 따른 트랜잭션 구현체도 대부분 만들어두어서
우리는 가져다 쓰기만 하면 된다. 그 인터페이스가 바로 PlatformTransactionManager이다. 
이 인터페이스에는 메서드가 단 3개이다: getTransaction(), commit(), rollback()



- 스프링의 트랜잭션 매니저와 트랜잭션 동기화 매니저
TransactionManager, TransactionSynchronizationManager
스프링이 제공하는 트랜잭션 매니저는 크게 2가지 역할을 한다:
트랜잭션 추상화, 리소스 동기화

리소스 동기화
트랜잭션을 유지하려면 트랜잭션의 시작부터 끝까지 같은 DB Connection을 유지해야 한다.
같은 Connection을 동기화(맞추어 사용)하기 위해서 이전에는 MemberServiceV2에서는 파라미터로 Connection을 전달했었다.

    private void accountTransferBizLogic(Connection conn, String toId, int money, String fromId) throws SQLException {
        Member fromMember = memberRepository.findById(conn, fromId);
        Member toMember = memberRepository.findById(conn, toId);

        memberRepository.update(conn, fromId, fromMember.getMoney() - money);
        validate(toMember); // 학습을 위한 의도적 예외 발생 코드
        memberRepository.update(conn, toId, toMember.getMoney() + money);
    }

하지만 이 방식은 코드가 지저분해지는 것은 물론이고, 커넥션을 넘기는 메서드와 넘기지 않는 메서드를 중복해서 만들어야 하는 등
여러가지 단점들이 많다.

스프링의 트랜잭션 매니저는 내부에서 '트랜잭션 동기화 매니저'를 사용하고 있다. 이는 ThreadLocal을 사용해서 Connection을 동기화해준다.
그렇기 때문에 멀티쓰레드 상황에 안전하게 Connection을 동기화할 수 있다.

동작방식 순서는 다음과 같다:
1) 트랜잭션을 시작하기 위해 Connection이 필요하다. 그러면 서비스 로직에서 트랜잭션 매니저에 트랜잭션 시작 요청
2) 트랜잭션 매니저가 DataSource를 통해 Connection을 만들고 트랜잭션 관련 작업들을 시작
3) 트랜잭션 매니저는 트랜잭션이 시작된 Connection을 트랜잭션 동기화 매니저에 보관
   서비스에서 직접 Connection을 들고 있는 게 아니라 트랜잭션 동기화 매니저가 이 Connection을 갖고 있다. 
4) Repository는 트랜잭션 동기화 매니저에 보관된 Connection을 꺼내서 사용★
   이 덕분에 파라미터로 Connection을 전달하지 않아도 된다.
5) 트랜잭션이 종료되면 트랜잭션 매니저는 트랜잭션 동기화 매니저에 보관된 Connection을 통해 트랜잭션을 종료하고, Connection을 닫는다.

참고로, ThreadLocal을 사용하면 각각의 쓰레드마다 별도의 저장소가 부여된다. 따라서 해당 쓰레드만 해당 데이터에 접근할 수 있다. 



- RepositoryV2 --> V3 변경점
1) getConnection 부분 변경:
    private Connection getConnection() throws SQLException {
        // 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.
        Connection conn = DataSourceUtils.getConnection(dataSource);
        log.info("get connection = {}, class = {}", conn, conn.getClass());
        return conn;
    }

여기서, 만약 트랜잭션 동기화 매니저가 관리하는 Connection이 있으면 해당 Connection을 반환하고,
관리하는 Connection이 없는 경우 새로운 Connection을 생성해서 반환한다.


2) Connection을 닫는 방식 변경: 
    private void close(Connection conn, Statement stmt, ResultSet rs) {
        JdbcUtils.closeResultSet(rs);
        JdbcUtils.closeStatement(stmt);
        // 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.
        DataSourceUtils.releaseConnection(conn, dataSource);
    }

conn.close()를 사용해서 직접 Connection을 닫아버리면 Connection이 유지되지 않는 문제가 발생한다.
이 Connection은 이후 로직은 물론이고, 트랜잭션을 종료하기 전까지 살아 있어야 한다.
그러므로 DataSourceUtils.releaseConnection() 메서드는 Connection을 Repository에서 바로 닫지는 않는다.
왜냐하면 서비스 요청으로부터 비롯된 트랜잭션 동기화 매니저가 관리하는 Connection이기 때문이다.
이 Connection은 이후에 서비스 계층에서 로직이 끝나면 트랜잭션 매니저를 통해 닫아준다.

만약 위의 경우처럼 트랜잭션 동기화 매니저가 관리하는 Connection이 아닌 경우는 어떨까?
이때는 서비스에서 넘어온 것이 아니고, 해당 Repository에서 시작한 Connection이라고 인식하므로 해당 Connection을 닫아버린다.


3) Connection을 파라미터로 전달하는 메서드들 삭제:
    findById()와 update() 메서드 



- MemberServiceV2 --> V3 변경점
1) DataSource 의존성 삭제 후 트랜잭션 매니저 의존성 주입
    private final PlatformTransactionManager transactionManager;
    private final MemberRepositoryV3 memberRepository;

트랜잭션 매니저를 주입 받는 모습이다. 지금은 JDBC 기술을 사용 중이기 때문에
DataSourceTransactionManager를 구현체로 주입 받아야 한다.
만약 JPA 기술로 변경된다면 JpaTransactionManager를 주입 받으면 된다.


2) 비즈니스 로직에 트랜잭션 관련 로직 리팩토링
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {

        // 트랜잭션 시작
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());

        try {
            accountTransferBizLogic(toId, money, fromId);
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw new IllegalStateException(e);
        }
    }

transactionManager.getTransaction() 메서드는 트랜잭션을 시작해주며, TransactionStatus라는 객체를 반환한다.
이 객체에는 현재 트랜잭션의 상태 정보가 포함되어 있으며, 이 정보는 트랜잭션을 커밋, 롤백할 때 필요하다.
    transactionManager.commit(status);
    transactionManager.rollback(status);


3) 비즈니스 로직에 있던 Connection 파라미터 전달 부분 삭제
    private void accountTransferBizLogic(String toId, int money, String fromId) throws SQLException {
        Member fromMember = memberRepository.findById(fromId);
        Member toMember = memberRepository.findById(toId);

        memberRepository.update(fromId, fromMember.getMoney() - money);
        validate(toMember); // 학습을 위한 의도적 예외 발생 코드
        memberRepository.update(toId, toMember.getMoney() + money);
    }



- MemberServiceV3 --> V3_1 테스트 코드 변경점

    @BeforeEach
    void before() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        memberRepository = new MemberRepositoryV3(dataSource);

        // Connection을 넣어주기 위한 DataSource를 넣어주어야 함
        PlatformTransactionManager transactionManager = new DataSourceTransactionManager(dataSource);
        memberService = new MemberServiceV3_1(transactionManager, memberRepository);
    }

위에서 언급했듯이, JDBC 기술을 사용하므로 JDBC용 트랜잭션 매니저인 DataSourceTransactionManager를 구현체로 선택하고 있다.
트랜잭션 매니저는 DataSource를 통해 Connection을 생성하므로 구현체 생성자에 DataSource를 넣어주어야 한다.



- ★★트랜잭션 매니저의 동작흐름을 관련 코드와 함께 다시 살펴보기★★

    public void accountTransfer(String fromId, String toId, int money) throws SQLException {

        // 트랜잭션 시작
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());

        try {
            accountTransferBizLogic(toId, money, fromId);
            transactionManager.commit(status);
        } catch (Exception e) {
            transactionManager.rollback(status);
            throw new IllegalStateException(e);
        }
    }

    @BeforeEach
    void before() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        memberRepository = new MemberRepositoryV3(dataSource);

        // Connection을 넣어주기 위한 DataSource를 넣어주어야 함
        PlatformTransactionManager transactionManager = new DataSourceTransactionManager(dataSource);
        memberService = new MemberServiceV3_1(transactionManager, memberRepository);
    }

1) 트랜잭션을 시작하기 위해 Connection이 필요하다. 그러면 서비스 로직에서 트랜잭션 매니저에 트랜잭션 시작 요청
        TransactionStatus status = transactionManager.getTransaction(new DefaultTransactionDefinition());

2) 트랜잭션을 시작하려면 DB Connection이 필요하다.
   그렇기 때문에 트랜잭션 매니저는 내부에 갖고 있는 DataSource를 통해 Connection을 만든다.
        PlatformTransactionManager transactionManager = new DataSourceTransactionManager(dataSource);

3) Connection을 만들었으니 트랜잭션을 시작한다. 즉, 수동커밋 모드로 전환한다.(내부 로직 코드는 생략)

4) 트랜잭션 매니저는 트랜잭션이 시작된 3)의 Connection을 트랜잭션 동기화 매니저에 보관한다.
   이렇게, 서비스에서 직접 Connection을 들고 있는 게 아니라 트랜잭션 동기화 매니저가 이 Connection을 갖고 있다. 

5) 트랜잭션 동기화 매니저는 ThreadLocal에 Connection을 보관한다.
이 덕분에 멀티 쓰레드 환경에서 안전하게 Connection을 보관할 수 있는 것이다.

6) 이제 서비스 계층의 비즈니스 로직이 시작된다. 이때 비즈니스 로직 내부에는 Repository의 메서드를 호출하는 부분들이 있다.
Repository 메서드들은 트랜잭션이 시작된 Connection이 필요한데, 이전에 서비스 계층으로부터 파라미터로 전달 받는 방식에서와는 다르게,
트랜잭션 동기화 매니저에 보관된 Connection을 꺼내서 사용한다.
Connection을 꺼낼 때는 아래와 같이 DataSourceUtils.getConnection(dataSource); 메서드를 호출한다: 

    private Connection getConnection() throws SQLException {
        Connection conn = DataSourceUtils.getConnection(dataSource);
        log.info("get connection = {}, class = {}", conn, conn.getClass());
        return conn;
    }

    try {
        conn = getConnection();
        ... 
        int resultSize = pstmt.executeUpdate();
        log.info("resultSize = {}", resultSize);
    } ...

이 과정에서 비즈니스 로직 내의 모든 Repository 메서드들은 트랜잭션 동기화 매니저에 보관된 동일한 Connection을 사용하는 것이기 때문에 
트랜잭션의 원자성이 잘 지켜진다.


7) 각 Repository 메서드가 진행될 때마다 DataSourceUtils.releaseConnection(conn, dataSource);이 호출된다.

   ㅡㅡㅡ Service 中 ㅡㅡㅡ
    private void accountTransferBizLogic(String toId, int money, String fromId) throws SQLException {
        Member fromMember = memberRepository.findById(fromId);
        Member toMember = memberRepository.findById(toId);

        memberRepository.update(fromId, fromMember.getMoney() - money);
        validate(toMember); // 학습을 위한 의도적 예외 발생 코드
        memberRepository.update(toId, toMember.getMoney() + money);
    }

    ㅡㅡㅡ Repository 中 ㅡㅡㅡ
    private void close(Connection conn, Statement stmt, ResultSet rs) {
        JdbcUtils.closeResultSet(rs);
        JdbcUtils.closeStatement(stmt);
        // 트랜잭션 동기화를 사용하려면 DataSourceUtils를 사용해야 한다.
        DataSourceUtils.releaseConnection(conn, dataSource);
    }

DataSourceUtils.releaseConnection(conn, dataSource); 메서드를 사용하면
    * 트랜잭션 동기화 매니저가 관리하는 Connection이면 Repository에서 닫지 않는다.
    * 트랜잭션 동기화 매니저가 관리하는 Connection이 아니면 Repository에서 바로 닫는다.
즉, 조건에 따라 Connection을 닫을지 말지를 판단하는 메서드라고 볼 수 있다.

트랜잭션 동기화 매니저가 관리하는 Connection일 때 Repository에서 Connection을 닫으면 안 되는 이유는,
트랜잭션 종료 가능 여부는 트랜잭션 동기화 매니저가 아는 것이지, Repository가 알 수 있는 게 아니기 때문이다.


8) 비즈니스 로직이 끝나면 트랜잭션 매니저에게 커밋 또는 롤백 요청을 한다.

    try {
        accountTransferBizLogic(toId, money, fromId);
        transactionManager.commit(status);
    } catch (Exception e) {
        transactionManager.rollback(status);
        throw new IllegalStateException(e);
    }
    
트랜잭션 매니저가 트랜잭션을 종료하려면 DB에 동기화된 Connection이 필요하다.
그렇기 때문에 트랜잭션 매니저는 트랜잭션 동기화 매니저로부터 동기화된 Connection을 획득하고, 획득한 Connection을 통해 
DB에 트랜잭션을 커밋 또는 롤백한다.

9) 트랜잭션 커밋 또는 롤백이 완료된 후 트랜잭션 동기화 매니저에 있는 Connection을 정리하고, ThreadLocal도 정리한다. 
이때, Connection이 자동커밋 모드로 다시 변경되고, close() 메서드를 호출하여 Connection을 종료한다.
Connection Pool을 사용하는 경우 close() 메서드를 호출하면 Connection이 죽지 않고 Pool에 반환된다.



- 트랜잭션 템플릿
스프링에서 제공하는 트랜잭션 매니저를 사용하고 나니 코드가 많이 깔끔해지고 OCP 문제가 많이 해결되었다.
그러나 여전히 Service에서 트랜잭션을 시작할 때 try-catch 블록 코드가 반복되는 문제가 존재한다. 
하지만 개발자가 실질적으로 유지보수 해야 하는 부분은 비즈니스 로직 코드 뿐이다. 
핵심 비즈니스 로직만 extract 해서 빼놓긴 했지만 여전히 코드가 지저분해보인다.
스프링은 '템플릿 콜백 패턴'을 적용한 TransactionTemplate이라는 편리한 기능을 제공하는데, 이것을 사용하면 이 문제를 해결할 수 있다.

TransactionTemplate의 메서드는 다음과 같다:
* execute()
    응답 값이 있을 때 사용

* executeWithoutResult()
    응답 값이 없을 때 사용

트랜잭션 템플릿의 기본동작은 다음과 같다:
    commit 조건: 비즈니스 로직 정상 수행
    rollback 조건: Unchecked 예외가 발생해야 힘. Checked 예외의 경우에는 commit을 한다.
스프링의 기본 룰이 Runtime이나 Unchecked 예외가 발생할 때 rollback 하는 것이라 그렇다.


- MemberServiceV3_1 -> V3_2 변경점

1) 의존성 주입 부분

    @Slf4j
    public class MemberServiceV3_2 {

        private final TransactionTemplate txTemplate;
        private final MemberRepositoryV3 memberRepository;

        public MemberServiceV3_2(PlatformTransactionManager transactionManager, MemberRepositoryV3 memberRepository) {
            this.txTemplate = new TransactionTemplate(transactionManager);
            this.memberRepository = memberRepository;
        }
    
        ... 
    }

* 생성자에 로직이 들어가기 때문에 @RequiredArgsConstructor를 지웠다. 

* 생성자를 보면 PlatformTransactionManager와 MemberRepositoryV3 객체를 Service 클래스에 주입하고 있다.

* TransactionTemplate을 사용하려면 트랜잭션 매니저가 필요하다. 그렇기 때문에 위에서 주입한
  PlatformTransactionManager를 TransactionTemplate 필드의 생성자에 주입해준다.
  물론 TransactionTemplate은 밖에서 Bean으로 등록해놓고 주입 받아도 되지만
  본 예제에서는 관례를 따라 PlatformTransactionManager를 주입을 받아, TransactionTemplate의 생성자에
  그 트랜잭션 매니저를 파라미터로 전달해준다. 이렇게 하면 TransactionTemplate은 내부적으로 PlatformTransactionManager를
  이용하여 트랜잭션을 시작하고 커밋하거나 롤백한다.


2) 비즈니스 로직 코드
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        txTemplate.executeWithoutResult((status) -> {
            // 비즈니스 로직
            try {
                accountTransferBizLogic(toId, money, fromId);
            } catch (SQLException e) {
                throw new IllegalStateException(e);
            }
        });
    }

* 콜백 패턴이란, 특정 작업이 완료된 후 호출될 함수를 정의하는 디자인 패턴으로, txTemplate.executeWithoutResult()는 콜백 패턴 메서드이다.
람다식 (status) -> { ... } 부분을 '콜백 함수'라고 부르며, 이 함수는 트랜잭션 내에서 실행할 코드를 정의한다.
executeWithoutResult() 메서드는 트랜잭션 경계를 정의하고, 위에서 언급된 람다식 콜백 함수를 인자로 받는다.
이런 식으로 콜백 패턴을 통해 트랜잭션 내에서 실행할 비즈니스 로직을 정의하고 있으며, 트랜잭션 경계를 명시적으로 설정하였다.
또, 트랜잭션 관리 로직과 비즈니스 로직이 분리되어 유지보수성을 높였다.
executeWithoutResult() 메서드에서는 비즈니스 로직이 시작되기 전에 트랜잭션을 시작한다.
비즈니스 로직 수행이 정상적으로 진행되면 커밋하고, 중간에 예외가 발생하면 롤백한다.

* 람다식 내부를 보면, accountTransferBizLogic() 메서드가 있는데, 이 메서드를 호출하면 SQLException이라는 Checked 예외를 넘겨준다.
그러나 람다식에서 Checked 예외를 밖으로 던질 수 없기 때문에,
Unchecked 예외인 IllegalStateException으로 예외를 전환하느라 try-catch 문을 사용한 것이다.

* 트랜잭션 템플릿 덕분에 트랜잭션 시작 및 커밋/롤백 코드가 모두 제거되었다.



- MemberServiceV3_1Test --> V3_2Test 변경점
    * V3_1-->V3_2로 바꾼 부분 외에는 없음

결과적으로, 트랜잭션 템플릿 덕분에 트랜잭션 사용을 위한 반복적인 코드를 제거할 수 있었고,
테스트 코드에서 필드와 생성자에 V3_1에서 V3_2로 적용시키는 부분들 외에는 테스트 코드의 변경 사항은 없었다.



- MemberServiceV3_2의 한계점
그러나, 여전히 서비스 계층에서 txTemplate.executeWithoutResult()와 같은 트랜잭션 관련 코드를 작성해야 한다는 한계점이 있다.
사실 서비스 계층의 핵심 기능은 비즈니스 로직 메서드이고 트랜잭션은 핵심 기능은 아니고 부가 기능이다.
만약 이러한 부가적인 기능과 관련된 코드가 사라진다면 핵심 기능의 유지보수가 더 용이해질 것이다.
이를 위해 트랜잭션 AOP를 사용하는 것이 좋겠다는 아이디어가 떠오를 수밖에 없다.



- 트랜잭션 AOP와 프록시 도입: @Transactional
트랜잭션 템플릿을 적용하여 트랜잭션을 처리하는 반복 코드를 제거할 수 있었다.
그러나 여전히 서비스 로직의 영역에서 직접 트랜잭션을 시작하고 종료하고 있다는 점에서
서비스 계층에 순수한 비즈니스 로직만 남긴다는 목표를 아직 달성하지 못했다.
이 문제는 Spring AOP를 통해 프록시를 도입하여 해결할 수 있다.

결론부터 미리 말하자면 @Transactional 애너테이션을 사용하면 Spring이 AOP 방식으로 트랜잭션을 편리하게 처리해주기 때문에,
우리는 @Transactional 애너테이션만 달아주면 된다.



- 프록시를 도입할 때 트랜잭션의 흐름
프록시를 사용하게 되면 요청자와 서비스 계층사이에 '트랜잭션 프록시'라는 계층이 중간에 껴들어간다.
그래서 사용자가 서비스를 요청하게 되면 진짜 서비스가 아니라 트랜잭션 프록시가 서비스보다 먼저 요청을 받아들여
트랜잭션을 시작하고, 트랜잭션이 시작되면 프록시에서 서비스 계층에 실제 서비스 메서드를 호출한다.  

이 조건에서는 클라이언트가 서비스를 직접 호출하는 것이 아니라 프록시에서 클라이언트 대신에 서비스를 호출하게 되는 것이다.
이 프록시는 개발자가 직접 만드는 게 아니고 Spring이 자동으로 만들어준다.
실제와 다를 수 있지만 프록시 코드의 예시를 보여주자면 아래와 같다:

public class TransactionProxy {

    private MemberService target;

    public void logic() {
        //트랜잭션 시작
        TransactionStatus status = transactionManager.getTransaction(..);
        try {
            //실제 대상 호출
                target.logic();
                transactionManager.commit(status); //성공시 커밋
        } catch (Exception e) {
            transactionManager.rollback(status); //실패시 롤백
            throw new IllegalStateException(e);
        }
    }
}

TransactionProxy 코드를 보면 MemberService 타입의 target 필드가 있는 것을 볼 수 있다.
그리고 logic() 메서드 내부의 try 블록 부분을 보면 target.logic() 메서드를 볼 수 있는데, target.logic()이 바로 비즈니스로직이다.
위와 같이 해놓으면 서비스 코드에 트랜잭션과 관련된 코드를 아래와 같이 제거할 수 있다: 

public class Service {
    public void logic() {
        //트랜잭션 관련 코드 제거, 순수 비즈니스 로직만 남음
        bizLogic(fromId, toId, money);
    }
}

이제서야 서비스 계층에 순수한 비즈니스 로직만 남게 되었다.



- 스프링 AOP와 프록시: @Transactional
위에서 설명한 프록시는 사실 스프링 AOP를 사용하면 매우 편리하게 적용시킬 수 있다.
스프링 AOP를 직접 사용해서 트랜잭션을 처리해도 되지만, 트랜잭션은 매우 중요한 기능이고, 전세계 누구나 다 사용하는 기능이다.
그렇기 때문에 스프링은 친절하게도 트랜잭션 AOP를 처리하기 위한 모든 기능을 이미 다 만들어 놓았다.
심지어 스프링 부트를 사용하면 트랜잭션 AOP를 처리하기 위한 스프링 Bean들도 자동으로 등록해준다.
그렇기 때문에 개발자는 그냥 트랜잭션이 필요한 곳에 @Transactional 애너테이션만 딸깍 달아주면 끝이다...
스프링 트랜잭션 AOP가 이 애너테이션을 인식해서 알아서 트랜잭션 프록시를 자동으로 적용해준다. 
주의해야 할 점은 이를 위해서 org.springframework 으로 시작하는 @Transactional로 선택해야 한다.

* 참고: 스프링 트랜잭션 AOP를 위해 스프링에서 제공하는 클래스들:
어드바이저: BeanFactoryTransactionAttributeSourceAdvisor
포인트컷: TransactionAttributeSourcePointcut
어드바이스: TransactionInterceptor
위 Bean들은 스프링부트를 사용하면 스프링 컨테이너에 자동으로 등록된다.



- MemberServiceV3_2 --> V3_3 변경점
    * 트랜잭션 매니저와 관련된 코드들 삭제
    * 비즈니스 로직 메서드에 @Transactional 애너테이션 적용

@Slf4j
public class MemberServiceV3_3 {

    private final MemberRepositoryV3 memberRepository;

    public MemberServiceV3_3(MemberRepositoryV3 memberRepository) {
        this.memberRepository = memberRepository;
    }

    @Transactional
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        accountTransferBizLogic(toId, money, fromId);
    }

    ... 이하 생략
}

스프링 트랜잭션 AOP를 적용하니 깔끔하게 비즈니스 로직만 남은 모습을 볼 수 있다.
참고로 위 예제에서는 메서드 위에 @Transcational 을 적용했는데, 이 애너테이션을 클래스 앞에 붙이면
외부에서 호출 가능한 public 메서드들마다 트랜잭션 AOP가 적용된다.



- MemberServiceV3_2Test --> V3_3Test 변경점

@Slf4j
@SpringBootTest
class MemberServiceV3_3Test {
    ... static final 상수 변경 없음

    @Autowired
    private MemberRepositoryV3 memberRepository;

    @Autowired
    private MemberServiceV3_3 memberService;

    @TestConfiguration
    static class TestConfig {
        @Bean
        DataSource dataSource() {
            return new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        }

        @Bean
        PlatformTransactionManager transactionManager() {
            return new DataSourceTransactionManager(dataSource());
        }

        @Bean
        MemberRepositoryV3 memberRepositoryV3() {
            return new MemberRepositoryV3(dataSource());
        }

        @Bean
        MemberServiceV3_3 memberServiceV3_3() {
            return new MemberServiceV3_3((memberRepositoryV3()));
        }
    }

    ... @AfterEach 변경 없음

    ... 비즈니스 로직 변경 없음
    }
}

* @SpringBootTest 적용 및 @Autowired를 통한 의존성 주입
스프링 AOP를 적용하려면 일단 기본적으로 스프링 컨테이너가 필요하지만 지금까지는 @SpringBootTest 애너테이션 없이 테스트를 해왔다.
이 말은 지금까지는 순수 자바 코드로 테스트를 진행해왔다는 뜻이다.
@SpringBootTest 애너테이션이 있으면 테스트 시 스프링부트를 통해 스프링 컨테이너를 생성할 수 있고, 테스트에서 @Autowired 등을 통해 스프링 컨테이너가 관리하는 빈들을 사용할 수 있다.

* 트랜잭션 및 Connection과 관련된 기존 코드 삭제

* 스프링 빈 등록 1: @TestConfiguration
테스트 안에서 내부 설정 클래스를 만들 때 이 애너테이션을 사용하면 @SpringBootTest에 의해 스프링 부트가 자동으로 만들어주는 빈들 외에도, 테스트에 필요한 추가적인 빈들을 등록할 수 있다. 그리하여 TestConfig 내부 설정 클래스에 등록한 빈들은 다음과 같다:

    1) DataSource
    RepositoryV3에서도 필요하고, 트랜잭션 매니저에서도 필요하기 때문에 DataSource를 스프링 빈으로 등록

    2) PlatformTransactionManager (구현체: DataSourceTransactionManager(dataSource()) )
    트랜잭션 매니저를 스프링 빈으로 등록. 스프링이 제공하는 트랜잭션 AOP는
    스프링 빈에 등록된 트랜잭션 매니저를 찾아서 사용하기 때문에 트랜잭션 매니저를 스프링 빈으로 등록해두어야 한다.

    3), 4) (RepositoryV3, ServiceV3_3는 설명 생략)



- 프록시 적용 여부 확인해보기
위 코드대로 하면 테스트는 잘 통과한다. 그런데 궁금한 게 있다. 위에서 Spring AOP를 사용하면 프록시를 사용한다고 했는데,
프록시가 실제로 사용되고 있는지 확인하고 싶다.

    @Test
    @DisplayName("프록시 확인용 테스트")
    void aopCheck() {
        log.info("memberService class = {}", memberService.getClass());
        log.info("memberRepository class = {}", memberRepository.getClass());
        assertThat(AopUtils.isAopProxy(memberService)).isTrue();
        assertThat(AopUtils.isAopProxy(memberRepository)).isFalse();
    }

Service와 Repository의 getClass 로그를 비교해보면 아래와 같다:
memberService class = class hello.springdb.service.MemberServiceV3_3$$SpringCGLIB$$0
memberRepository class = class hello.springdb.repository.MemberRepositoryV3

그리고 assertThat을 통해 테스트 결과를 보아도
memberService는 AopProxy가 true라고 나오고,
memberRepository는 AopProxy가 false라고 나온다.
memberService는 @Transactional을 이용하여 AOP를 적용시켰지만,
memberRepository는 AOP와 관련된 아무 것도 한 게 없기 때문에 타당한 결과이다.

프록시를 도입하면 스프링이 Service 로직을 오버라이드 하여 상속을 받는다. 
즉, 위에서 'TransactionProxy'라는 클래스에 대해 언급했던 부분의 public void logic() { ... } 을 만들어낸다.
이 예제에서는 그 'TransactionProxy'라는 클래스가 바로 MemberServiceV3_3$$SpringCGLIB$$0 인 것이다.
이 프록시 클래스는 CGLIB를 사용하여 생성되었음을 알 수 있고, 런타임에 동적으로 생성된다. 

런타임에 생성되기 때문에 정확한 코드는 알 수 없지만 일반적인 CGLIB 프록시 클래스는 대략 이런 식으로 생겼다:

public class MemberServiceV3_3$$SpringCGLIB$$0 extends MemberServiceV3_3 {
    private MethodInterceptor interceptor;

    public MemberServiceV3_3$$SpringCGLIB$$0(MethodInterceptor interceptor) {
        this.interceptor = interceptor;
    }

    @Override
    public void accountTransfer(String fromId, String toId, int money) throws SQLException {
        Method method = MemberServiceV3_3.class.getMethod("accountTransfer", String.class, String.class, int.class);
        Object[] args = new Object[] { fromId, toId, money };
        interceptor.intercept(this, method, args, new MethodProxy() {
            @Override
            public Object invokeSuper(Object obj, Object[] args) throws Throwable {
                return MemberServiceV3_3.super.accountTransfer((String) args[0], (String) args[1], (int) args[2]);
            }
        });
    }

    // 기타 오버라이드된 메서드들...
}

스프링의 AOP 기능을 사용하여 동적으로 생성된 이 CGLIB 프록시 클래스는 애플리케이션 실행 시 스프링 컨테이너에 빈으로 등록된다.
그리고 클라이언트가 해당 빈을 주입받을 때 프록시 인스턴스가 반환된다.



- 트랜잭션 AOP가 적용되었을 때 전체 흐름 설명
1) 테스트 케이스, 컨트롤러 등에서 비즈니스 로직 호출
참고: 서비스를 의존성 주입했는데, 실제로 의존성이 주입된 것은 진짜 서비스가 아니라 프록시 서비스이다.
    memberService.accountTransfer(...);

2) 해당 로직을 받은 프록시 서비스는 스프링 컨테이너에 등록된 트랜잭션 매니저를 통해 트랜잭션을 시작한다.
이때, 트랜잭션 매니저의 DataSource가 Connection을 획득하고, 해당 Connection을 수동커밋 모드로 설정한다.
참고: 트랜잭션 매니저는 DataSource를 주입 받은 상태이다. 그래야 Connection을 획득할 수 있기 때문이다.
    transactionManager.getTransaction();
    conn.setAutoCommit(false);

3) 트랜잭션 매니저는 트랜잭션 동기화 매니저에 현재 트랜잭션과 연결된 Connection을 보관한다.
트랜잭션 동기화 매니저는 현재 Thread에 트랜잭션과 Connection을 저장하여 이후 호출에서 사용할 수 있게 한다.

4) 트랜잭션이 시작된 후, 프록시 서비스에서 실제 서비스 메서드를 호출하고, 실제 서비스 로직이 수행된다.

5) 서비스 로직 중에 데이터 접근을 위한 repository의 메서드를 호출한다.

6) repository의 메서드는 트랜잭션 동기화 매니저에 보관된 Connection을 획득하여 데이터 접근 로직을 수행한다.
이때, 트랜잭션 동기화 매니저에 의해 동일한 Connection이 사용되므로, 동일 트랜잭션 내에서 여러 Repository 메서드가 호출되더라도
트랜잭션 일관성이 유지된다.

7) 비즈니스 로직이 성공적이면 프록시 서비스는 트랜잭션 매니저를 통해 commit한다.
        transcactionManager.commit(status);
    비즈니스 로직 중 Unchecked 예외가 발생하면 프록시 서비스는 트랜잭션 매니저를 통해 rollback한다.
        transactionManager.rollback(status);

8) 트랜잭션이 종료되면 트랜잭션 매니저는 Connection을 트랜잭션 동기화 매니저에서 제거하고, Connection을 반환한다.
이때, Connection은 커넥션 설정에 따라 Connection Pool로 반환되거나 닫힌다.



- 참고사항: 선언적 트랜잭션 관리와 프로그래밍 트랜잭션 관리
1) 선언적 트랜잭션 관리
    @Transactional 애너테이션 하나만으로 편리하게 트랜잭션을 적용하는 방식.
    현재는 애너테이션으로 선언적 트랜잭션을 하지만 과거에는 XML 파일 방식으로 선언적 트랜잭션을 사용했다.
    현재는 압도적인 다수가 실무에서 애너테이션 선언적 방식으로 사용한다.

2) 프로그래밍 트랜잭션 관리
    트랜잭션 매니저 또는 트랜잭션 템플릿 등을 사용하여 트랜잭션과 관련된 코드들을 직접 작성하는 방식.
    현재 실무에서 거의 사용되지 않음. 단, 테스트 시에 트랜잭션이 제대로 먹나 확인하는 용도로 가끔 사용될 때가 있다.



- 스프링부트의 DataSource 자동 등록
스프링부트가 등장하기 전에는 DataSource와 트랜잭션 매니저를 개발자가 직접 스프링 빈으로 등록해서 사용했다.
그런데 스프링부트로 개발에 입문한 개발자들은 DataSource나 트랜잭션 매니저를 직접 등록한 적이 없을 것이다.
위에서 살펴본 테스트 코드에서도 마찬가지다.

        @Bean
        DataSource dataSource() {
            return new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        }

기존에는 위와 같이 DataSource와 트랜잭션 매니저를 직접 스프링 빈으로 등록해야 했다.
그런데 스프링부트가 나오면서 많은 부분이 자동화되었다. 

스프링부트는 컨테이너에 자동으로 DataSource를 빈으로 등록한다. 자동으로 등록된 스프링 빈의 이름은 'dataSource'이다.
만약 개발자가 직접 커스터마이징을 위해 DataSource를 빈으로 등록할 경우엔 스프링부트가 충돌 방지를 위해 자동으로 등록하지 않는다.

스프링부트에서 dataSource를 자동으로 등록하는 방법은 설정 파일을 이용하는 것이다.
application.properties를 예로 들면 다음과 같다: 

    spring.datasource.url=jdbc:h2:tcp://localhost/~/test
    spring.datasource.username=sa
    spring.datasource.password=

이렇게 설정 파일에서 datasource 관련 설정값들을 입력해주면 위 설정값들에 맞추어 자동으로 dataSource를 빈으로 등록해준다.
만약 저기서 spring.datasource.url 속성이 없을 경우엔 메모리 DB를 생성하려고 시도한다.



- 스프링부트의 트랜잭션 매니저 자동 등록

        @Bean
        PlatformTransactionManager transactionManager() {
            return new DataSourceTransactionManager(dataSource());
        }

스프링부트는 PlatformTrasnactionManager 인터페이스의 적절한 구현체를 자동으로 빈으로 등록해준다.
자동으로 등록되는 스프링 빈 이름은 'transactionManager'이다.
마찬가지로 커스터마이징을 위해 개발자가 직접 트랜잭션 매니저를 빈으로 등록하면 자동 등록이 되지 않는다.

어떤 트랜잭션 매니저 구현체를 선택할지는 현재 등록된 라이브러리를 보고 판단한다.
만약 JDBC 기술을 사용하고 있다면 DataSourceTransactionManager를 PlatformTrasnactionManager의 구현체로 등록하고,
JPA를 사용하고 있다면 JpaTransactionManager를 등록한다.
참고로 이 JpaTransactionManager는 DataSourceTransactionManager가 제공하는 기능도 대부분 지원한다.
그렇기 때문에 JDBC와 JPA 두 개 모두 사용할 경우 JpaTransactionManager를 빈으로 등록한다.



- 빈 등록 코드 지워서 적용해보기
    @TestConfiguration
    static class TestConfig {

        private final DataSource dataSource;

        public TestConfig(DataSource dataSource) {
            this.dataSource = dataSource;
        }

        @Bean
        MemberRepositoryV3 memberRepositoryV3() {
            return new MemberRepositoryV3(dataSource);
        }
        ... 이하 생략
    }

@Bean 애너테이션을 사용하여 DataSource와 PlatformTransactionManager를 빈으로 등록하는 코드를 삭제하고,
DataSource를 스프링 컨테이너에서 주입 받았다. 그렇기 때문에 아래와 같이 필드 주입 방식으로 주입 받을 수도 있다:

    @TestConfiguration
    static class TestConfig {

        @Autowired private DataSource dataSource;

        @Bean
        MemberRepositoryV3 memberRepositoryV3() {
            return new MemberRepositoryV3(dataSource);
        }
        ... 이하 생략
    }



- 체크예외와 언체크예외
SQLException을 서비스 계층에서 없애는 것뿐만 아니라, 스프링의 예외처리 메커니즘을 활용하기 위해서,
그리고 실무에서 예외가 터질 때 언제 Checked 예외 또는 Unchecked 예외를 사용할지 판단하려면 자바 예외에 대한 이해가 필요하다.

* 예외의 계층도
Object - Throwable - Exception -->
				1) 각종 checked 예외들(IOException, SQLExcpetion, ClassNotFoundException, ... )
				2) RuntimeException (언체크 예외 = 런타임 예외)

* 최상위 예외는 Throwable이라고 할 수 있으며, Throwable은 Exception과 Error로 나뉜다.

* Error는 메모리 부족이나 심각한 시스템 오류와 같이 JVM 레벨의 심각한 문제를 나타낸다.
이는 애플리케이션에서 복구할 수 없는 '시스템 예외'이며, OutofMemoryError, StackOverflowError가 대표적인 예이다.
따라서 Error는 예외가 터지도록 놔두는 게 오히려 좋다.
만약 catch 블록에 Throwable을 사용하면 무슨 일이 발생할까? Error는 애플리케이션이 종료되어야 오히려 더 안전한 경우이다.
만약 OutofMemoryError가 발생했는데 시스템을 종료하지 않으면 무슨 일이 벌어질까? 
다른 중요한 작업들이 중단되거나 실패하게 되고, DB 트랜잭션이 중간에 멈추거나 중요한 데이터를 저장하지 못하는 등
예상치 못한 시스템 장애가 곳곳에서 일어나게 될 것이다. 쉽게 말하면 '서버가 터진다.'
Error가 발생한 것도 좋은 일인 건 아니지만 그렇다고 Error를 무시하는 건 더 위험한 것이다.
Error가 발생할 때는 차라리 애플리케이션을 종료시켜버리는 게 더 큰 사고를 방지하는 것이다.

* Exception은 크게 위와 같이 세 갈래로 갈라지며,
Exception 중에 오직 RuntimeException 예외들만 언체크 예외이다. 언체크 예외는 '런타임 예외'라고도 부른다.
RuntimeException 외에는 모두 체크 예외이다. 체크 예외란 컴파일러가 체크해주기 때문에 애플리케이션 실행 자체가 막히게 하는 예외이다.



- 예외의 기본 규칙
예외는 폭탄 돌리기와 같다:
1) 내가 직접 잡아서 처리하거나
2) 내가 처리할 수 없으면 밖으로 던진다.

예를 들어 Repository에서 예외가 발생했다고 하자. 그런데 Repository 자체에서 이걸 잡아서 처리를 못한다.
그러면 이 Repository는 자신을 호출한 Service에게 예외를 던진다. Service에서는 이걸 처리할 수 있다고 하자.
그러면 Service에서 catch로 잡아서 해당 예외를 처리하고 catch 블록의 코드 및 finally 블록의 코드 결과를 반환한다.

그런데 만약 아무도 예외를 catch하지 않고 넘기기만 하면 어떻게 될까?
    1) 자바 main() 쓰레드의 경우
    메서드 호출의 근원이 되는 main() 메서드까지 예외가 거슬러 올라가고, 자바 main() 쓰레드에서 예외 로그를 출력하고 시스템을 종료한다. 

    2) 웹 애플리케이션의 경우
    시스템이 종료되지 않고, WAS가 해당 예외를 받아서 처리해준다. 이때, 일반적으로 WAS는 개발자가 지정한 오류 페이지를 사용자에게 보여준다.

    * 참고
    Exception을 catch로 잡으면 그 하위 예외들을 모두 잡는다.
    Exception을 throws로 던지면 그 하위 예외들도 모두 던진다.
    


- 체크 예외 기본 이해1
Exception을 상속하는 예외는 체크예외가 되며, 체크예외들을 던질 경우 throws 선언을 해주어야 한다.
그렇지 않으면 컴파일 에러가 발생한다.

    static class MyCheckedException extends Exception {
        public MyCheckedException(String message) {
            super(message);
        }
    }

위 코드에서 MyCheckedException은 "extends Exception"을 하고 있다. Exception을 상속하게 되면 MyCheckedException이 체크 예외가 된다.

    static class Repository {

        public void callRepository() {
            throw new MyCheckedException("ex");
        }

    }

callRepository() 메서드를 보면 내부에서 throw new MyCheckedException("ex"); 을 던지고 있는데, 
위와 같이 작성하면 "throw new MyCheckedException("ex");" 이 부분에 빨간 밑줄이 그어진다.
이는 MyCheckedException은 체크 예외인데 왜 throws를 안 하고 있냐 이 뜻이다.

그래서 다음과 같이 throws 선언을 해주어야 한다: 
        public void callRepository() throws MyCheckedException {
            throw new MyCheckedException("ex");
        }

이렇게, Exception을 상속하는 예외는 체크예외가 되며, 체크예외들을 던질 경우 throws 선언을 해주어야 한다.



- 체크 예외 기본 이해2
    static class Service {
        Repository repository = new Repository();

        public void catchMethod() {
            repository.callRepository();
        }
    }

위와 같은 코드를 작성하면 "callRepository"라는 글자 밑에 빨간 밑줄이 생긴다.
이는 컴파일러가 catch를 하든지 throw를 하든지 하라는 뜻이다.
throws를 하면 catchMethod()를 호출하는 곳으로 예외 처리를 떠넘기겠다는 것이고, 이번 예제에서는 그냥 catch하여 처리할 것이다.
Alt + Enter로 자동완성하면 된다: 

    public void catchMethod() {
        try {
            repository.callRepository();
        } catch (MyCheckedException e) {
            log.info("예외 처리, message = {}", e.getMessage(), e);
        }
    }

Exception의 예외 메시지는 e.getMessage()를 통해 얻을 수 있고,
마지막 파라미터에 e를 입력하면 스택 트레이스로 출력해준다.

이번엔 서비스에서도 catch 하지 않고 또 던지는 경우이다:
    public void throwMethod() throws MyCheckedException {
        repository.callRepository();
    }

테스트는 아래와 같이 하면 된다:
    @Test
    void checked_throw() {
        Service service = new Service();
        assertThatThrownBy(() -> service.throwMethod())
                .isInstanceOf(MyCheckedException.class);
    }



- 체크예외의 장단점
    장점)
    * 개발자가 실수로 예외를 누락하지 않도록 컴파일러를 통해 문제를 미리 알려주기 때문에 안전 장치로 기능한다.

    단점) 
    * 체크 예외들을 반드시 잡거나 던져야 하기 때문에 번거롭다. 그래서 안 좋은 걸 알면서도 throws Exception 해버리는 경우가 많다.
    * 의존관계에 따른 단점이 있다. 이 부분은 뒤에서 자세히 설명한다.



- 언체크 예외 기본 이해
RuntimeException과 그 자손 예외들은 언체크 예외이다. 말 그대로 컴파일러가 체크하지 못하는 예외들이다.

    static class MyUncheckedException extends RuntimeException {
        public MyUncheckedException(String message) {
            super(message);
        }
    }

런타임 예외는 체크 예외와 기본적으로 동일하나, "throws를 생략할 수 있다"는 차이점이 있다. 생략하면 자동으로 throws 한다.
체크 예외와 언체크 예외의 차이는 이 차이밖에 없다. 하지만 이 작은 차이가 많은 차이를 만들어낸다.

    static class Repository {
        public void callRepository() {
            throw new MyUncheckedException("ex");
        }
    }

이번에는 throws 선언을 하지 않아도 throw new MyUncheckedException("ex"); 이 부분에 빨간 밑줄이 안 생긴다.
왜냐하면 MyUncheckedException은 언체크 예외이기 때문에 컴파일러가 throws 또는 catch하라고 닥달하지 않는 것이다.
물론 선언을 해도 선언을 하지 않은 것과 똑같다.

    public void throwMethod() {
        repository.callRepository();
    }

이렇게 throws 문을 적지 않아도 알아서 던진다. 물론 throws 문을 적어도 된다.

    @Test
    void unchecked_throw() {
        Service service = new Service();
        assertThatThrownBy(() -> service.throwMethod())
                .isInstanceOf(MyUncheckedException.class);
    }



- 런타임 예외의 장단점
    장점)
    * throws 문을 작성하지 않아도 자동으로 throw 하므로 신경쓰고 싶지 않은 런타임 예외를 무시할 수 있다. 

    단점) 
    * 개발자의 실수로 예외를 누락할 수 있다.



- 예외 적용의 두 가지 원칙
그렇다면 체크 예외와 런타임 예외를 각각 언제 사용하는 것이 좋을까?
기본 원칙 두 가지만 기억하자:

1) 기본적으로 런타임 예외를 사용하자
2) 체크 예외는 비즈니스 로직 상 너무 중요해서 의도적으로 던지는 예외에만 사용하자. (사실 매우 드물게 사용된다)

해당 예외를 잡아서 반드시 처리해야 하는 문제일 때만 체크 예외를 사용해야 한다. 예를 들면 다음과 같다:
    * 계좌 이체 실패 예외
    * 결제 시 포인트 부족 예외
    * 로그인 ID, PW 불일치 예외
물론 위 예들에서 반드시 체크 예외로 만들어야 하는 것은 아니지만 계좌 이체 실패처럼 민감한 문제는 개발자가 실수로
예외를 놓치면 안 되는 경우가 대부분이므로 체크 예외로 만들어두면 컴파일러를 통해 예외를 놓쳤는지 안 놓쳤는지 체크할 수 있다.



- 기본적으로 런타임 예외를 사용해야 하는 이유
왜 런타임 예외를 기본으로 사용해야 할까? 왜 체크 예외를 기본적으로 사용하는 것은 왜 문제가 될까? 

예를 들어: 
Repository에서는 SQLException 체크 예외를 던지고,
NetworkClient는 외부 네트워크에 접속해서 어떤 기능을 처리하는 객체인데 ConnectException 체크 예외를 던진다고 하자.

Service에서 Repository와 NetworkClient를 둘 다 호출한다고 해보자. 그러면 SQLException과 ConnectException이 Service로 던져질 것이다.
그런데 딱봐도 저 예외들은 Service에서 처리할 만한 예외들이 아니다... 그래서 Service도 이 두 예외들을 그냥 던질 것이다.

    public void serviceMethod() throws SQLException, ConnectException {
        ...
    }

Service를 호출한 Controller에서도 마찬가지의 이유로 던진다고 하자:

    public ResponseDto controllerMethod() throws SQLException, ConnectException {
        ...
    }

웹 애플리케이션에서는 서블릿의 오류 페이지나 스프링 MVC가 제공하는 ControllerAdvice에서 이런 예외들을 공통으로 처리하는데,
이런 문제들은 일반적으로 사용자들에게 어떤 문제가 발생했는지 설명하기가 설득적인 목적이든 보안적인 목적이든 난해하다.
그래서 사용자에게는 "서비스에 문제가 있습니다" 라는 구체적이지 못한 메시지를 보여줄 수밖에 없다.
일반적으로 API라면 500을 사용하여 응답을 내려준다.

이렇게 해결이 불가능한 공통 예외는 별도의 오류 로그를 남기고, 개발자가 오류를 빨리 인지할 수 있도록 메일, 알림 등을 통해서 전달 받아야 한다. 예를 들어 SQLException이 잘못된 SQL을 작성해서 발생했다면, 개발자가 해당 SQL을 수정해서 배포하기 전까지 사용자는 같은 문제를 겪게 된다.


결국 체크 예외의 문제점은 두 가지로 요약할 수 있다:

1) 복구 불가능함
SQLException을 예로 들면, SQL 문법에 오타가 있는 경우라면 복구가 가능할 것이다. 그러나 DB 서버가 중간에 다운되었다거나 DB 자체에 문제가 발생하는 등의 문제들은 대부분 복구가 불가능하다. 당연히 대부분의 서비스나 컨트롤러는 이런 문제를 해결할 수도 없다.
그렇기 때문에 이런 문제들은 일관성 있게 공통으로 처리해야 한다:
    * 오류 로그 남기기
    * 개발자가 해당 오류 빠르게 인지하기
    * 서블릿 필터, 스프링 인터셉터, 스프링 ControllerAdvice 사용 등

2) 의존 관계 문제
체크 예외이기 때문에 어쩔 수 없이 연쇄적으로 throws 문을 통해 예외를 던져야 한다.
위 예제에서도 컨트롤러나 서비스 입장에서는 본인이 처리할 수 없어도 throws 문을 선언해야 했다.
이렇게 throws 문을 쓰게 되면 억지로 java.sql.SQLException에 의존하게 되는데,
만약 향후 JDBC에서 다른 기술로 변경한다면 어떻게 될까? throws 부분들 코드 다 바꿔야 한다...
이렇게, 체크 예외를 사용하면 단지 예외를 중간에서 다시 던지는 것일 뿐인데 특정 기술에 불필요하게 의존하게 된다.
그렇다고 Exception으로 퉁치는 것은 아주 좋지 않은 것이다. 이는 체크 예외의 의미를 퇴색시키는 코드이다.



- 런타임 예외 사용하기
런타임 예외를 사용하면 위에서 언급한 체크 예외의 문제점들이 해결된다. 
런타임 예외는 처리할 수 없는 곳에서 별도의 선언을 할 필요가 없기 때문에 서비스와 컨트롤러에서 throws를 할 필요가 없다.
알아서 내부적으로 예외가 던져져서 예외를 공통으로 처리하는 부분으로 도달하여 처리된다.

    static class RuntimeConnectException extends RuntimeException {
        public RuntimeConnectException(String message) {
            super(message);
        }
    }

    static class RuntimeSQLException extends RuntimeException {
        public RuntimeSQLException(Throwable cause) {
            super(cause);
        }
    }

    static class Repository {
        // 체크 예외를 잡아서 런타임 예외로 변환시켜 던지기
        public void callRepository() {
            try {
                runSQL();
            } catch (SQLException e) {
                throw new RuntimeSQLException(e);
            }
        }

        // 체크 예외
        public void runSQL() throws SQLException {
            throw new SQLException("ex");
        }
    }

    static class NetworkClient {
        public void callNetworkClient() {
            throw new RuntimeConnectException("연결 실패");
        }
    }

    static class Service {
        Repository repository = new Repository();
        NetworkClient networkClient = new NetworkClient();

        public void logic() {
            repository.callRepository();
            networkClient.callNetworkClient();
        }
    }

    static class Controller {
        Service service = new Service();

        public void request() {
            service.logic();
        }
    }

    @Test
    void unchecked() {
        Controller controller = new Controller();
        Assertions.assertThatThrownBy(() -> controller.request())
                .isInstanceOf(RuntimeSQLException.class);
    }

컨트롤러와 서비스 모두에서 throws 문이 사라지고 예외 의존성이 사라졌다.
그러므로 만약에 JDBC에서 다른 기술로 변경되어도 컨트롤러와 서비스 코드에 영향을 주지 않게 되었다.
단지 예외 공통 처리 부분에서만 변경 사항을 반영하여 수정해주면 된다.

자바에서 예외를 설계할 당시에는 체크 예외가 더 나은 것이라 생각했다. 그래서 자바가 기본으로 제공하는 기능들에는 체크 예외가 많다.
하지만 시간이 흐르면서 생각보다 복구가 안 되는 체크 예외들이 많아졌고, 특히 라이브러리를 점점 더 많이 사용하면서 처리해야 하는 예외도 더 많아졌다. 체크 예외는 해당 라이브러리들이 제공하는 모든 예외를 처리할 수 없을 때마다 throws에 예외들을 덕지덕지 붙여야 했다. 
그래서 개발자들은 throws Exception 이라는 극단적인 방법도 자주 사용하게 되었다. 물론 이 방법은 결코 권장되지 않는 방법이다.

체크 예외의 이러한 문제점 때문에 대부분의 최근 라이브러리들은 런타임 예외를 기본으로 제공한다. 스프링도 대부분 런타임 예외를 제공한다.
런타임 예외는 필요하면 잡을 수도 있기 때문에 필요한 경우에는 잡아서 처리하고, 그렇지 않으면 자동으로 던져지게 둔다.
어차피 앞 부분에 공통으로 예외를 처리하는 곳에서 처리하면 되기 때문이다.

런타임 예외는 놓칠 수 있기 때문에 문서화가 굉장히 중요하며, 중요한 예외일 경우에는 throws를 사용하는 것이 권장된다:

  JPAEntityManager의 런타임 예외 문서화 예시:

    /**
      * Make an instance managed and persistent.
      * @param entity entity instance
      * @throws EntityExistsException if the entity already exists.
      * @throws IllegalArgumentException if the instance is not an
      * entity
      * @throws TransactionRequiredException if there is no transaction when
      * invoked on a container-managed entity manager of that is of type
      * <code>PersistenceContextType.TRANSACTION</code>
    */
    public void persist(Object entity);



- 예외 포함과 스택 트레이스
앞에서 다룬 예제 코드에도 나왔지만 체크 예외를 런타임 예외로 전환할 때는 반드시 기존 예외를 포함해야 한다.
그렇지 않으면 스택 트레이스를 확인할 때 심각한 문제가 발생한다.

스택 트레이스를 출력하는 방법은 위에서 언급했듯이, 로그 출력 마지막 파라미터에 예외 클래스를 넣어주면 된다.
    log.info("message={}", "message", ex)

* 참고: e.printStackTrace(); 이 방식으로 해도 예외 관련 내용이 출력되긴 하지만 이 방법은 좋지 않다.
단순 콘솔 출력이기 때문에 로그를 중앙에서 관리하기 어렵고, 로깅 레벨 설정이 불가능하고, 로그 저장 및 분석이 어렵기 때문이다.

    static class RuntimeSQLException extends RuntimeException {
        public RuntimeSQLException(Throwable cause) {
            super(cause);
        }
    }

    public void callRepository() {
        try {
            runSQL();
        } catch (SQLException e) {
            throw new RuntimeSQLException(e);
        }
    }

실무에서 자주 하는 실수는 throw new RuntimeSQLException(e); 부분에서
파라미터 e를 빼먹고 throw new RuntimeSQLException(); 라고 해버리는 것이다.
이렇게 해버리면 "Caused by: java.sql.SQLException: ex" 로 시작하는 로그가 안 뜬다. 즉, 스택 트레이스를 출력하지 않는다.
실제 체크 예외를 로그로 남기지 않는 것이 왜 심각한 문제냐면 저 Caused by 로그는 실제 문제의 원인을 찾는 데에 굉장히 큰 도움을 준다.
그런데 그 로그를 띄우지 않으면 문제가 발생했을 때 문제의 원인을 찾을 수 없게 되는 것이다.

Caused by 로그가 여러 개 발생하는 예외가 있는데, 그 중 가장 아래에 있는 Caused By 부분을 'Root Cause'라고 한다. 
이 Root Cause 부분부터 차례대로 고쳐 가면서 문제를 해결해야 하는데 Caused by 자체를 출력하지 않으면 문제 해결의 열쇠가 없는 셈이 된다.

정리하면, 체크 예외를 런타임 예외로 전환할 때는 반드시 기존 예외(e)를 생성자 파라미터로 넘겨서 스택 트레이스를 유지해야 한다.
즉, 저 위 코드로 따지면 생성자의 파라미터로 정의된 cause를 넘겨야 한다.



- 체크 예외와 인터페이스
다시 메인 예제로 돌아와서, 트랜잭션 템플릿을 적용하여 서비스 계층의 순수성을 부여하는 데 어느 정도 크게 성공했다.
그러나 아직 서비스에 throws SQLException 코드가 남아 있다.

서비스가 처리할 수 없는 SQLException을 서비스가 위와 같이 가지고 있을 수밖에 없는 이유는 Repository에서 체크예외인 SQLException을 던졌기 때문이다. 서비스가 throws SQLException 코드를 사용하지 않으려면 넘겨 받는 예외가 런타임 예외여야 한다.

그 전에, MemberRepository 인터페이스를 도입하여 구현 기술을 쉽게 변경할 수 있게 해놓자.
미리 인터페이스를 만들지 않은 이유는, SQLException이 체크 예외이기 때문에, 인터페이스에도 체크 예외가 선언되어 있어야 하기 때문이다.
그렇게 되면 인터페이스 코드가 다음과 같이 지저분하게 될 것이다: 

    public interface MemberRepository {
        Member save(Member member) throws SQLException;
        Member findById(String memberId) throws SQLException;
        void update(String memberId, int money) throws SQLException;
        void delete(String memberId) throws SQLException;
    }

인터페이스는 특정 기술에 의존하지 않으려고 만드는 건데 위 코드는 이미 JDBC에 의존하고 있기 때문에 무의미한 인터페이스다.
인터페이스에는 throws 안 하고 구현체에만 throws 하면 되는 거 아닌가?
아니다. 불가능하다. 구현체가 체크 예외를 던지려면 인터페이스 메서드에 먼저 체크 예외를 던지는 부분이 선언되어 있어야 하기 때문이다.



- MemberRepositoryV4에 런타임 예외 적용시키기

* throws를 없애버린 모습
    @Override
    public Member save(Member member) {
        ...
    }

* 체크 예외 대신에 런타임 예외를 던지도록 변환시키는 모습. 기존 예외를 Throwable 파라미터로 넘기는 모습까지.
    } catch (SQLException e) {
        throw new MyDBException(e);
    }



- MemberServiceV4에서 throws SQLException 없애기

* MemberService에서 MemberRepositoryV4를 주입 받지 않고, MemberRepository 인터페이스를 주입 받게 해준다.
public class MemberServiceV4 {

    private final MemberRepository memberRepository;

    public MemberServiceV4(MemberRepository memberRepository) {
        this.memberRepository = memberRepository;
    }

    ...

}

* throws SQLException 없애기

* 그 외 코드 변경사항 없음

드디어 순수한 서비스가 완성되었다.



- MemberServiceV4Test 수정된 부분

    @Autowired
    private MemberRepository memberRepository;

    @Autowired
    private MemberServiceV4 memberService;

    @TestConfiguration
    static class TestConfig {

        @Autowired private DataSource dataSource;

        @Bean
        MemberRepository memberRepository() {
            return new MemberRepositoryV4_1(dataSource);
        }

        @Bean
        MemberServiceV4 memberServiceV4() {
            return new MemberServiceV4((memberRepository()));
        }
    }

의존성 주입 부분 + 빈 등록 부분 + throws SQLException 제거. 그 외 변경 사항 없음



- 데이터 접근 예외 직접 만들기
위 예제에서는 MyDBException이라는 예외만 넘어오기 때문에 예외의 정확한 원인을 구분할 수 없다는 단점이 있다.
만약 서비스 계층에서 특정 상황 별로 예외를 잡아서 상황에 맞는 적절한 예외 처리를 직접 하고 싶다면 어떻게 예외를 구분해서 처리할 수 있을까?

데이터를 DB에 저장할 때, 같은 ID가 이미 DB에 저장되어 있으면 DB에서 오류 코드를 반환하고, 이 오류 코드를 받은 JDBC 드라이버는 SQLException을 던진다. 그리고 사실 SQLException에는 DB가 제공하는 errorCode라는 것이 들어 있다. 이 errorCode를 이용하여 문제의 정확한 원인을 파악하고 거기에 맞는 예외를 던지면 된다.

만약 회원가입 시 DB에 이미 같은 아이디가 있으면 ID 뒤에 숫자를 붙여서 새로운 ID를 만든다고 해보자.
ID를 'hello'라고 입력하고 가입 시도를 했는데 이미 hello가 있는 경우, hello1234와 같이 뒤에 임의의 숫자를 붙여서 가입시킨다고 하자.
Repository에서 insert 쿼리를 날리는 메서드를 호출하면 JDBC 드라이버에서 DB에 insert 쿼리를 날린다.
DB는 unique 제약조건에 걸리는 것을 확인하고 DB 내부에 가지고 있는 오류 코드를 반환해준다.
예를 들어 PK가 중복일 경우 H2 DB에서는 23505라는 오류 코드를 반환한다고 하자. 참고로 오류 코드는 DB마다 다 다르다.
이 오류 코드를 받은 JDBC 드라이버는 SQLException을 만드는데, 그 안에 이 오류 코드 23505를 넣어둔다.
이 SQLException이 Repository에 넘어올 것이다. 이 오류 코드를 우리가 애플리케이션에서 직접 확인할 수 있다:
    e.getErrorCode(); (23505 반환)

참고로, H2 DB에서 23505는 unique 제약조건 오류이고, 42000은 SQL 문법 오류이다. 에러 코드는 DB마다 메뉴얼을 참고하면 된다.

다시 본론으로 돌아와서, 그러면 서비스 계층에서 클라이언트로부터 입력 받은 hello에 임의의 숫자를 붙이기 위해서는 어찌됐든 SQLExcpetion의 
에러코드 23505를 획득해야 한다. 그런데 SQLException을 넘겨 받게 되면 SQLException을 import 해야 하고,
그렇게 되면 서비스 계층의 순수성에 문제가 생기는데 이 경우는 어떻게 해야 할까?

이를 위해서는 Repository 계층에서 예외를 변환시켜서 던져주어야 한다.

    public class MyDuplicateKeyException extends MyDBException {
        ... 생성자들
    }

* 이 예외는 개발자가 직접 만든 커스텀 예외이기 때문에 JDBC나 JPA 같은 특정 기술에 종속적이지 않다.
* 앞에서 다룬 예제에서 만들었던 런타임 커스텀 예외인 MyDBException을 상속했기 때문에 MyDuplicateKeyException도 런타임 예외이다.



- 런타임 커스텀 예외 테스트 코드
@Slf4j
public class ExConvertV1Test {

    @RequiredArgsConstructor
    static class Repository {

        private final DataSource dataSource;

        public Member save(Member member) {
            String sql = "insert into member(member_id, money) values(?,?)";
            Connection conn = null;
            PreparedStatement pstmt = null;

            try {
                conn = dataSource.getConnection();
                pstmt = conn.prepareStatement(sql);
                pstmt.setString(1, member.getMemberId());
                pstmt.setInt(2, member.getMoney());
                pstmt.executeUpdate();
                return member;
            } catch (SQLException e) {
                // H2 DB
                if (e.getErrorCode() == 23505) {
                    throw new MyDuplicateKeyException(e);
                }
                throw new MyDBException(e);
            } finally {
                JdbcUtils.closeStatement(pstmt);
                JdbcUtils.closeConnection(conn);
            }
        }
    }

    @RequiredArgsConstructor
    static class Service {
        private final Repository repository;

        public void create(String memberId) {
            try {
                repository.save(new Member(memberId, 0));
                log.info("savedId = {}", memberId);
            } catch (MyDuplicateKeyException e) {
                log.info("키 중복, 복구 시도");
                String retryId = generateNewId(memberId);
                log.info("retryId = {}", retryId);
                repository.save(new Member(retryId, 0));
            }
        }

        private String generateNewId(String memberId) {
            return memberId + new Random().nextInt(10000);
        }
    }

    Repository repository;
    Service service;

    @BeforeEach
    void init() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        repository = new Repository(dataSource);
        service = new Service(repository);
    }

    @Test
    void duplicateKeySave() {
        service.create("myId");
        service.create("myId"); // 같은 ID 저장 시도
    }
}



- 테스트 코드 Repository 부분

save() 메서드의 catch 부분만 살펴보자: 
    catch (SQLException e) {
        // H2 DB
        if (e.getErrorCode() == 23505) {
            throw new MyDuplicateKeyException(e);
        }
            throw new MyDBException(e);
    } 

JDBC 드라이버로부터 온 SQLException을 catch해서 에러 코드가 23505일 경우 MyDuplicateKeyException을 Caused by가 뜰 수 있게 던지고,
그 외의 경우에는 일반적인 SQLException을 런타임 예외로 변환한 MyDBException을 던지게 해놓았다.



- 테스트 코드 Service 부분

try - catch 블록만 살펴보자:
    public void create(String memberId) {
        try {
            repository.save(new Member(memberId, 0));
            log.info("savedId = {}", memberId);
        } catch (MyDuplicateKeyException e) {
            log.info("키 중복, 복구 시도");
            String retryId = generateNewId(memberId);
            log.info("retryId = {}", retryId);
            repository.save(new Member(retryId, 0));
        }
    }

중복된 아이디를 파라미터로 받을 경우 MyDuplicateKeyException을 catch 하여 다른 곳으로 던지는 것이 아니라
새로운 ID를 생성 및 저장하도록 서비스에서 직접 예외를 처리하고 있다.
이와 같이, 어떤 예외들은 에러 코드가 다양하게 담겨 있어 다른 커스텀 예외 클래스를 적용시켜서 예외 처리를 해줄 수 있다.

그런데 문제가 아직 남아 있다. Repository에서 조건문에 에러 코드를 대입하여 예외를 생성하게 해놓았는데,
만약 DB를 바꾸면 어떻게 될까? DB마다 에러 코드가 다르다고 했으므로 DB가 변경되면 에러 코드도 모두 변경해야 하는 일이 발생할 수 있다.
하지만 다행히도 이 일은 Spring이 다 해준다. 이는 스프링 예외 추상화 부분에서 다시 설명한다.



- 테스트 의존성 셋팅 및 테스트 실행 코드
    (필드 선언)
    Repository repository;
    Service service;

    @BeforeEach
    void init() {
        DriverManagerDataSource dataSource = new DriverManagerDataSource(URL, USERNAME, PASSWORD);
        repository = new Repository(dataSource);
        service = new Service(repository);
    }

    @Test
    void duplicateKeySave() {
        service.create("myId");
        service.create("myId"); // 같은 ID 저장 시도
    }

* 초기화 셋팅 부분
    DriverManagerDataSource를 사용하여 DataSource를 생성하고, 이를 통해 Repository를 초기화한다.
    또, 그렇게 초기화된 Repository를 이용해 Service 객체를 생성한다.

* 실행 코드 부분
    중복되는 아이디 값을 입력하고, 로그를 살펴본다. 검증 부분은 작성하지 않았다.



- 스프링의 데이터 접근 관련 예외 추상화
스프링은 데이터 접근과 관련된 예외들을 추상화해준다. RuntimeException을 상속하는 DataAccessException이 바로 그것이다.
DataAccessException이 데이터 접근 관련 예외의 최상위 예외이며, 이는 두 자손으로 갈라진다:

    1) NonTransientDataAccessException
    2) TransientDataAccessException

Transient는 일시적이라는 의미로, 동일한 SQL을 재시도 했을 때 성공할 가능성이 있다는 의미이다. 예를 들면 쿼리 타임아웃, 락 등에 의한 쿼리 실패 때 TransientDataAccessException이 발생할 수 있다. 이런 오류들은 DB 상태가 괜찮아지거나 락이 풀렸을 때 재시도하면 성공할 가능성이 있다.

NonTransient는 일시적인 문제가 아니라는 의미로, 같은 SQL을 그대로 재시도하면 실패한다.
원인으로는 SQL 문법 오류, DB 제약조건 위배 등이 있다.

이 두 예외들은 또 하위에 다양한 수십 가지의 데이터 접근과 관련된 예외들을 가진다.
사실 앞 실습에서 다룬 예외 클래스 같은 것들도 이미 스프링이 다 제공하고 있는 것들이다.
각각의 예외들은 특정 기술에 종속적이지 않게 설계되어 있기 때문에 서비스 계층에서도 스프링이 제공하는 이 예외들을 사용하면 된다.
에러 코드 번호를 DB 메뉴얼을 가서 확인한 후에 런타임 예외 생성해서 체크 예외를 그 런타임 예외로 변환시키는 등
개발자가 이런 과정들을 직접 하는 건 굉장히 시간과 노력이 많이 드는 작업이며, 현실성이 없다. 

그렇기 때문에 JDBC를 사용하든 JPA를 사용하든 발생하는 예외를 스프링이 제공하는 예외로 변환해주는 역할을 스프링이 제공하는 것이다.

    @Test
    void springExceptionTranslator() {
        String sql = "select bad grammar example";

        try {
            Connection conn = dataSource.getConnection();
            PreparedStatement pstmt = conn.prepareStatement(sql);
            pstmt.executeQuery();
        } catch (SQLException e) {
            SQLErrorCodeSQLExceptionTranslator exTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);
            DataAccessException resultEx = exTranslator.translate("select", sql, e);
            log.info("resultEx = ", resultEx);
            
            assertThat(e.getErrorCode()).isEqualTo(42000);
            assertThat(resultEx.getClass()).isEqualTo(BadSqlGrammarException.class);
        }
    }

* SQLErrorCodeSQLExceptionTranslator exTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);
이 부분을 보면 스프링이 제공하는 SQLErrorCodeSQLExceptionTranslator 객체를 생성하고, 여기에 dataSource를 생성자 파라미터로 넣어준다.
SQLErrorCodeSQLExceptionTranslator 클래스는 SQLException을 Spring의 추상화된 데이터 접근 예외 (DataAccessException)로 변환하는 데 사용되며, DB 에러 코드를 기반으로 해당 에러 코드에 해당하는 DataAccessException의 자손 예외로 변환시켜주는 객체이다.

* DataAccessException resultEx = exTranslator.translate("select", sql, e);
이 부분에서는 SQLException을 Spring의 DataAccessException으로 변환한다.
여기서
"select"는 예외가 발생한 작업의 이름이라 문자열을 자유롭게 입력하면 되고,
sql은 실행한 SQL 구문이며,
e는 발생한 SQLException이다.
translate() 메서드 결과 DataAccessException의 자손인 BadSqlGrammarException으로 예외가 변환된다.

그런데, DB마다 에러 코드가 다 다른데 스프링은 어떤 DB를 사용하는지 어떻게 알고 에러 코드를 알게 되는 걸까?
이것은 org.springframework.jdbc.support.sql-error-codes.xml 이라는 xml 파일을 읽고 알게되는 것이다.
이 xml 파일에는 MySQL, H2, HSQL, MSSQL, Oracle 등 개발자들이 주로 사용하는 RDB들의 별로 에러 코드를 정리해놓은 내용들이 쭉 나온다.  



- 스프링 예외 추상화 적용하기 - MemberRepositoryV4_2 변경점
    private final DataSource dataSource;
    private final SQLExceptionTranslator exTranslator;

    public MemberRepositoryV4_2(DataSource dataSource) {
        this.dataSource = dataSource;
        this.exTranslator = new SQLErrorCodeSQLExceptionTranslator(dataSource);
    }

필드로는 SQLExceptionTranslator라는 인터페이스를 선언하고, 구현체는 생성자를 통해 SQLErrorCodeSQLExceptionTranslator를 적용한다.
이때, dataSource를 SQLErrorCodeSQLExceptionTranslator의 생성자에 넣어주는 이유는 어떤 DB를 사용하는지 등에 대한 정보를 
구현체에서 꺼내 쓰기 때문이다.

    catch (SQLException e) {
        throw exTranslator.translate("save", sql, e);
    }

이제 이렇게 exTranslator의 translate() 메서드만 사용하면 끝이다.



- MemberServiceV4Test 테스트 코드 

    @Bean
    MemberRepository memberRepository() {
        return new MemberRepositoryV4_2(dataSource);
    }

MemberRepositoryV4_1 이라고 되어 있던 부분을 MemberRepositoryV4_2 라고만 수정. 그 외 코드 건드리지 않음.
이게 인터페이스의 힘이다...



- Repository JDBC 반복 코드 문제 해결
이제 Service는 오로지 스프링 외에 다른 것에는 의존하지 않는 정말 순수한 상태가 되었다. 
하지만 Repository의 코드는 JDBC 떡칠이 되어 있어 현재 매우 지저분하다: 

    @Override
    public Member findById(String memberId) {
        String sql = "select * from member where member_id = ?";

        Connection conn = null;
        PreparedStatement pstmt = null;
        ResultSet rs = null;

        try {
            conn = getConnection();
            pstmt = conn.prepareStatement(sql);
            pstmt.setString(1, memberId);

            rs = pstmt.executeQuery();

            if (rs.next()) {
                Member member = new Member();
                member.setMemberId(rs.getString("member_id"));
                member.setMoney(rs.getInt("money"));

                return member;
            } else {
                throw new NoSuchElementException("member not found memberId = " + memberId);
            }
        } catch (SQLException e) {
            throw exTranslator.translate("findById", sql, e);
        } finally {
            close(conn, pstmt, rs);
        }
    }

사실상 Repository 메서드들은 아래의 일정한 패턴을 갖고 있다: 
    * Connection 조회
    * Connection 동기화
    * 쿼리 실행
    * 결과 바인딩
    * 예외 발생 시 스프링 예외 변환기 실행

이러한 반복적인 코드들을 효과적으로 처리하는 방법 중 하나가 바로 템플릿 콜백 패턴이다. 앞에서 살펴본 트랜잭션 템플릿이랑 비슷한 것이다.
Spring에서는 JDBC 반복 문제를 해결하기 위해 JdbcTemplate이라는 템플릿을 제공한다.



- MemberRepositoryV5 변경점

* 필드 및 생성자 변경점

@Slf4j
public class MemberRepositoryV5 implements MemberRepository {

    private final JdbcTemplate jdbcTemplate;

    public MemberRepositoryV5(DataSource dataSource) {
        this.jdbcTemplate = new JdbcTemplate(dataSource);
    }
    
    ...
}

필드에는 오직 JdbcTemplate만 남으며, 생성자에 이 JdbcTemplate에 DataSource를 넣어서 주입받는다.



* save 메서드 변경점
    @Override
    public Member save(Member member) {
        String sql = "insert into member(member_id, money) values (?, ?)";
        jdbcTemplate.update(sql, member.getMemberId(), member.getMoney());
        return member;
    }

이전에 있던 커넥션 처리, 쿼리 실행, 결과 바인딩, 스프링 데이터 접근 예외 처리를 이 한 줄에서 다 해준다:
    jdbcTemplate.update(sql, member.getMemberId(), member.getMoney());


* findById 메서드 변경점
    @Override
    public Member findById(String memberId) {
        String sql = "select * from member where member_id = ?";
        Member member = jdbcTemplate.queryForObject(sql, memberRowMapper(), memberId);
        return member;
    }

    private RowMapper<Member> memberRowMapper() {
        return (rs, rowNum) -> {
            Member member = new Member();
            member.setMemberId(rs.getString("member_id"));
            member.setMoney(rs.getInt("money"));
            return member;
        };
    }
조회의 경우, 반환되는 데이터를 Member 객체로 변환해주어야 하기 때문에 이렇게 별도의 맵퍼 메서드가 필요하다.
queryForObject() 메서드는 SQL 쿼리의 파라미터 자리표시자 '?'에 전달된 값을 안전하게 바인딩해주어 SQL 인젝션 공격을 방지한다.
    'sql'은 실행할 SQL 쿼리를 의미한다.
    'memberRowMapper()' 메서드는 결과 집합 ResultSet을 Member 객체로 맵핑하는 RowMapper이다.
    'memberId'는 SQL 쿼리의 파라미터 자리표시자 '?'에 바인딩할 값이다.

RowMapper라는 말은 말 그대로 반환 받은 데이터 행을 객체로 맵핑해준다는 뜻이다.
RowMapper는 인터페이스이고, return 문에는 이 인터페이스의 mapRow() 메서드를 람다식 안에 생략하여 표현하였다.
rs는 ResultSet 객체이고, rowNum은 현재 행의 번호를 의미한다.

member.setMemberId(rs.getString("member_id"));
member.setMoney(rs.getInt("money"));
이 두 부분은 ResultSet에서 각각 member_id 컬럼과 money 컬럼의 값을 읽어와 각각 memeberId, money 필드에 값을 입력해준다.
그리하여 맵핑된 Member 객체를 반환한다. 


* update 메서드 변경점
    @Override
    public void update(String memberId, int money) {
        String sql = "update member set money = ? where member_id = ?";
        jdbcTemplate.update(sql, money, memberId);
    }


* delete 메서드 변경점
    @Override
    public void delete(String memberId) {
        String sql = "delete from member where member_id = ?";
        jdbcTemplate.update(sql, memberId);
    }


이와 같이, JdbcTemplate은 JDBC로 개발할 때 발생하는 반복적인 코드들을 대부분 해결해준다. 
트랜잭션을 위한 Connection 동기화는 물론이고, 예외 발생시 Spring 예외 변환기도 자동으로 실행해준다.


